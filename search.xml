<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>有趣的函数接口</title>
      <link href="/2019/09/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/09/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看spring源码路径解析的时候，遇见了<code>helper.replacePlaceholders(text, this::getPropertyAsRawString);</code>。这里有个很奇怪的<code>this::getPropertyAsRawString</code>。<code>::</code>这个符号在C++中很眼熟，但是在java中还是第一次见（是我太菜没怎么学过java8，后面一定要补上。先在此记录。）,也不知道传了什么东西过去。</p><a id="more"></a><p>在好奇心的促使下，我点进了方法<code>replacePlaceholders</code>发现参数列表为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</span><br><span class="line">    <span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 发现第二个参数是<code>PlaceholderResolver</code>类型，而这个类型是一个<code>FunctionalInterface</code>接口，其源码如下：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Strategy interface used to resolve replacement values for placeholders contained in Strings.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaceholderResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Resolve the supplied placeholder name to the replacement value.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> placeholderName the name of the placeholder to resolve</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the replacement value, or &#123;<span class="doctag">@code</span> null&#125; if no replacement is to be made</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：FunctionalInterface注解作用"><a href="#问题：FunctionalInterface注解作用" class="headerlink" title="问题：FunctionalInterface注解作用"></a>问题：FunctionalInterface注解作用</h2><p>如这个注解的名字所示，这个接口只是向大家声明该接口是一个函数接口。而声明为函数接口，有如下要求：</p><ul><li>只能有一个抽象函数(但是有例外，详情见下)。</li><li>可以有default修饰的方法，因为default修饰的方法是已经实现了的</li><li>函数接口中抽象函数可以有多个，但是除了自定义的抽象函数之外的抽象函数必须是Object中已实现的方法。（如：下面的代码）   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaceholderResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hh "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果不是Object中已经实现的方法，则会报错。如下图：</p><p><img src="https://user-images.githubusercontent.com/33340562/64415173-626eab00-d0c7-11e9-99a4-c8344c257eb9.png" alt="image"></p><p>知道函数接口的定义后，那函数接口怎么使用呢？以及他的作用</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>定义一个函数接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaceholderResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">resolvePlaceholder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个将函数接口作为参数的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">    placeholderResolver.resolvePlaceholder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在定义一个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是print方法"</span>)</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在就可以愉快的使用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">this</span>::print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而上面调用test方法后就会输出在执行<code>placeholderResolver.resolvePlaceholder(“啦啦啦”);</code>时输出<code>我是print方法</code>。其作用也就是将print方法赋给PlaceholderResolver中的resolvePlaceholder，所以在调用resolvePlaceholder方法会执行print。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>究其到底函数接口只是一个语法糖，它是java8一个新的语法糖。它的效果等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">new</span> PlaceholderResolver() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在调用resolvePPlaceholder方法时会调用print方法。这样使用函数接口替代匿名内部类，可以是代码更加简洁。但要注意的是print方法要和resolvePlaceholder方法的参数列表、返回参数一致，方法名可以不一致。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ant风格</title>
      <link href="/2019/09/01/Ant%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/09/01/Ant%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在阅读dalao的文章时，看到<code>支持Ant风格</code>。遂对<code>Ant风格</code>产生了好奇。遂写此blog以做笔记。</p><blockquote><p>Ant风格：就是匹配<code>路径</code>和<code>url</code>的一种规则。例如：我们常见的<code>C:/project/*.html</code>匹配C盘目录下project文件夹中的所有html文件。<br><a id="more"></a></p></blockquote><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><table><thead><tr><th>符号</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>?</td><td style="text-align:right">匹配任何单字符</td></tr><tr><td>*</td><td style="text-align:right">匹配0或者任意数量的字符</td></tr><tr><td>**</td><td style="text-align:right">匹配0或者更多的目录</td></tr></tbody></table><p>例如<br>URL路径 | 说明<br>–|–:<br>/project/<em>.a|匹配项目根路径下所有在project路径下的.a文件<br>/project/p?ttern|匹配项目根路径下 /project/pattern 和 /app/pXttern,但是不包括/app/pttern<br>/<strong>/example|匹配项目根路径下 /project/example, /project/foow/example, 和 /example<br>/project/</strong>/dir/file.</em>|匹配项目根路径下/project/dir/file.jsp, /project/foow/dir/file.html,/project/foow/bar/dir/file.pdf<br>/*<em>/</em>.jsp|匹配项目根路径下任何的.jsp 文件</p><p>注意：如果一个路径存在多个匹配，那么将选择最长的匹配。<br>例如：URL请求/project/dir/file.jsp，现在存在两个路径匹配模式/*<em>/</em>.jsp和/project/dir/<em>.jsp，那么会根据模式/project/dir/</em>.jsp来匹配</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>schemaLocation值必须具有偶数个URI</title>
      <link href="/2019/09/01/schemaLocation%E5%80%BC%E5%BF%85%E9%A1%BB%E5%85%B7%E6%9C%89%E5%81%B6%E6%95%B0%E4%B8%AAURI/"/>
      <url>/2019/09/01/schemaLocation%E5%80%BC%E5%BF%85%E9%A1%BB%E5%85%B7%E6%9C%89%E5%81%B6%E6%95%B0%E4%B8%AAURI/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习并使用spring框架开发已经有了一段很长的时间了，但是之前没有把在学习过程中遇见关于spring的错误积累下来。所以从现在开始，将在此开辟一博客收集我遇见的奇葩错误。</p><h2 id="错误一-SchemaLocation-schemaLocation-值必须具有偶数个-URI"><a href="#错误一-SchemaLocation-schemaLocation-值必须具有偶数个-URI" class="headerlink" title="错误一  SchemaLocation: schemaLocation 值必须具有偶数个 URI"></a>错误一  SchemaLocation: schemaLocation 值必须具有偶数个 URI</h2><blockquote><p>该错误是我在学习<code>ignoreDependencyInterface</code>和<code>ignoreDependencyType</code>之间的区别及使用的时候发现的。   </p></blockquote><a id="more"></a><p>我在配置spring的beans.xml时，设置<code><a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a>&lt;/context:annotation-config&gt;</code>。发现要在<code>beans</code>标签中加入<code>xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a></code>。（因为我们要用到context标签所以要引入context）</p><p>加入后运行。   </p><blockquote><p>代码提示报错   </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line <span class="number">52</span> in XML document from file [C:\Users\Administrator\Downloads\adaptive-loadbalance-master-<span class="number">154377</span>df0a8f753f2ea462ec15a6f76f882691bc\study\src\main\resources\META-INF\spring\camel-context.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: <span class="number">52</span>; columnNumber: <span class="number">30</span>; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 <span class="string">'context:annotation-config'</span> 的声明。</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">404</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">336</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">304</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">188</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">224</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">195</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">257</span>)</span><br><span class="line">at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:<span class="number">128</span>)</span><br><span class="line">at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:<span class="number">94</span>)</span><br><span class="line">at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:<span class="number">133</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:<span class="number">636</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">521</span>)</span><br><span class="line">at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:<span class="number">142</span>)</span><br><span class="line">at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:<span class="number">85</span>)</span><br><span class="line">at study.Application.main(Application.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>原因是因为在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"</span></span><br></pre></td></tr></table></figure></p><p>中要加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/context</span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/context/spring-context.xsd</span></span><br></pre></td></tr></table></figure></p><p>刚开始年轻的我只加入了一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/context</span></span><br></pre></td></tr></table></figure></p><p>导致报错<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.xml.sax.SAXParseException: SchemaLocation: schemaLocation 值 <span class="string">'http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd       http://www.springframework.org/schema/context'</span> 必须具有偶数个 URI。</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次错误，我们可以知道要在beans.xml中加入一个标签的流程如下（以context为例）：</p><p>第一步：加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br></pre></td></tr></table></figure></p><p>第二步：在xsi:schemaLocation中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/context</span></span><br></pre></td></tr></table></figure></p><p>第三步：在xsi:schemaLocation中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/spring-context.xsd</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 错误 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer神秘的toStringCache属性</title>
      <link href="/2019/08/17/StringBuffer%E7%A5%9E%E7%A7%98%E7%9A%84toStringCache%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/08/17/StringBuffer%E7%A5%9E%E7%A7%98%E7%9A%84toStringCache%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>大家都知道直接对String字符串进行拼接等操作时，会创建大量的String对象。因此用String直接进行这些操作效率会很低。所以催生了StringBuilder和StringBuffer这两个类。这两个类基本相同，但是StringBuffer多了一个toStringCache变量（后面具体讲解该变量作用），并在方法体上加了<code>synchronized</code>。<br><a id="more"></a></p><h2 id="StringBuilder和StringBuffer的相同点"><a href="#StringBuilder和StringBuffer的相同点" class="headerlink" title="StringBuilder和StringBuffer的相同点"></a>StringBuilder和StringBuffer的相同点</h2><hr><ul><li>都继承于AbstractStringBuilder类。</li><li>都实现了java.io.Serializable, CharSequence接口。</li><li>字符串都是存储在一个字符数组中。<h2 id="StringBuilder和StringBuffer不同点一"><a href="#StringBuilder和StringBuffer不同点一" class="headerlink" title="StringBuilder和StringBuffer不同点一"></a>StringBuilder和StringBuffer不同点一</h2></li></ul><hr><p>StringBuffer是线程安全的，而StringBuilder是线程不安全的。那StringBuffer是怎么实现线程安全的呢？通过源码的对比，可以看到两个类的实现大致相同，不一样的就是StringBuffer在方法体加了synchronized。</p><h2 id="StringBuilder和StringBuffer不同点二"><a href="#StringBuilder和StringBuffer不同点二" class="headerlink" title="StringBuilder和StringBuffer不同点二"></a>StringBuilder和StringBuffer不同点二</h2><hr><p>在对比两个类的源码，发现StringBuffer多了一个toStringCache<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment"> * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure></p><p>这个属性的作用是缓存toString方法返回的最后一个值，当StringBuffer对象被修改时，这个变量都会被设置为NULL。</p><p><strong> toStringCache的作用 </strong></p><p>众所周知对字符串的操作效率StringBuilder &gt; StringBuffer &gt; String<br>也就是说StringBuffer的效率并不是最棒的，所以仍需提高，设置toStringCache的作用就是为了提高效率</p><p><strong> 问题来了：toStringCache是怎么提高效率的 </strong></p><h2 id="先看看StringBuilder和StringBuffer两个类中的toString方法"><a href="#先看看StringBuilder和StringBuffer两个类中的toString方法" class="headerlink" title="先看看StringBuilder和StringBuffer两个类中的toString方法"></a>先看看StringBuilder和StringBuffer两个类中的toString方法</h2><blockquote><p>StringBuffer的toString方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>StringBuilder的toString方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>从两个方法中可以看到StringBuffer已经将方法重写为了synchronized方法，已经实现了线程安全，可是方法的具体实现却不同。<br><strong> 两个方法创建String的方法分别为： </strong><br>new String(toStringCache, true);   –对应的构造方法–&gt;   String(char[] value, boolean share)<br>new String(value, 0, count); –&gt;对应的构造方法–&gt;  String(char value[], int offset, int count)  </p><p><strong> 所以现在需要去了解两个构造方法的不同 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处省略一部分代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count); <span class="comment">//复制数组到value</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的函数，就是这么简单粗暴</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">   <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">   <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看出<br>调用String(char[] value, boolean share) 不用复制数组<br>调用String(char value[], int offset, int count) 需要复制数组</p><p>再回到StringBuffer和StringBuilder的toString方法就知道StringBuffer只有当toStringCache是NULL的时候（也就是当字符串发生变化）需要复制数组，而StringBuilder的toString方法每次创建String都要复制数组。所以现在清楚了toStringCache就是这样提高一点点效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring中Bean的生命周期</title>
      <link href="/2019/07/22/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/07/22/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道Spring的IOC容器帮我们管理着Bean，我们可以从IOC容器中拿到我们想要的Bean对象。但是IOC是如何管理我们的Bean呢？下面将会从源码分析的角度来介绍Spring中Bean的生命周期。</p></blockquote><h2 id="BeanFactory源码的部分注释-可粗略看下，后面将会进行讲解"><a href="#BeanFactory源码的部分注释-可粗略看下，后面将会进行讲解" class="headerlink" title="BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解)"></a>BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解)</h2><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1. BeanNameAware's &#123;<span class="doctag">@code</span> setBeanName&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2. BeanClassLoaderAware's &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 3. BeanFactoryAware's &#123;<span class="doctag">@code</span> setBeanFactory&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 4. ResourceLoaderAware's &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 5. ApplicationEventPublisherAware's &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 6. MessageSourceAware's &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 7. ApplicationContextAware's &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 8. ServletContextAware's &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 9. &#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 10. InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 11. a custom init-method definition&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 12. &#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1. DisposableBean's &#123;<span class="doctag">@code</span> destroy&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2. a custom destroy-method definition</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><h3 id="注释翻译（翻译错的请轻喷）"><a href="#注释翻译（翻译错的请轻喷）" class="headerlink" title="注释翻译（翻译错的请轻喷）"></a>注释翻译（翻译错的请轻喷）</h3><p>Bean工厂的实现者应该尽可能支持标准的Bean生命周期接口。<br>Bean的初始化方法和他们标准的执行顺序如下：<br>1.BeanNameAware的setBeanName方法<br>2.BeanClassLoaderAware的setBeanClassLoader方法<br>3.BeanFactoryAware的setBeanFactory方法<br>4.ResourceLoaderAware的setResourceLoader方法<br>5.ApplicationEventPublisherAware的setApplicationEventPublisher方法<br>6.MessageSourceAware的setMessageSource方法<br>7.ApplicationContextAware的setApplicationContext方法<br>8.ServletContextAware的setServletContext方法<br>9.BeanPostProcessors的postProcessAfterInitialization方法<br>初始化完毕 -&gt; 进行我们的业务操作<br>Bean的关闭生命周期调用方法<br>1.DisposableBean的destroy方法<br>2.在配置文件中指定的destroy-method方法</p><p>看完这个注释后，我们将回到源码找到Bean执行以上方法的地方。<br>通过调试我们可以找到执行上述步骤的方法为initializeBean方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码就为该方法，我将该方法分为四部分。</p><h3 id="第一部分执行所有的Aware方法"><a href="#第一部分执行所有的Aware方法" class="headerlink" title="第一部分执行所有的Aware方法"></a>第一部分执行所有的Aware方法</h3><p>也就是上面提到的invokeAwareMethods方法<br>该方法将XXXAware对应的XXX对象传给bean。<br>例如BeanNameAware就会将beanName传给bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第二部分执行Bean后置处理器的postProcessBeforeInitialization方法"><a href="#第二部分执行Bean后置处理器的postProcessBeforeInitialization方法" class="headerlink" title="第二部分执行Bean后置处理器的postProcessBeforeInitialization方法"></a>第二部分执行Bean后置处理器的postProcessBeforeInitialization方法</h3><p>Bean后置处理器也就是BeanPostProcessor的实现类。也就是initializeBean方法中applyBeanPostProcessorsBeforeInitialization调用。<br>在applyBeanPostProcessorsBeforeInitialization方法中，Spring将遍历执行系统自带的和用户定义的所有Bean后置处理器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span>  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三部分执行Bean的Init方法"><a href="#第三部分执行Bean的Init方法" class="headerlink" title="第三部分执行Bean的Init方法"></a>第三部分执行Bean的Init方法</h3><p>在这里首先会判断Bean是否继承了InitializingBean接口<br>如果继承了InitializingBean接口，就调用InitializingBean接口的afterPropertiesSet方法。<br>然后判断用户在配置Bean的时候是否指定了init方法（xml配置为指定init-method，注解配置为PostConstruct）。<br>如果指定了就调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步"><a href="#第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步" class="headerlink" title="第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步"></a>第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步</h3><hr><blockquote><p>到此Bean的初始化就完成了。后面就是Bean的销毁<br>销毁跟初始化调用Bean的init方法一样，不过在销毁的时候是判断Bean是否实现了DisposableBean接口，如果实现了就调用DisposableBean的destroy方法。然后在判断Bean是否指定了销毁方法（xml方式是destroy-method，注解方式是@PreDestroy）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">            processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Invoking destroy() on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ((DisposableBean) bean).destroy();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((DisposableBean) bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.warn(msg, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(msg + <span class="string">": "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToCall = determineDestroyMethod();</span><br><span class="line">        <span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的生命周期总结"><a href="#Bean的生命周期总结" class="headerlink" title="Bean的生命周期总结"></a>Bean的生命周期总结</h2><blockquote><p>调用XXXAware方法的setXXX–&gt;调用Bean后置处理器的postProcessBeforeInitialization–&gt;调用InitializingBean接口的afterPropertiesSet方法–&gt;调用用户指定的初始方法–&gt;   业务  –&gt;调用DisposableBean接口的destory方法–&gt;调用用户指定的销毁方法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory、FactoryBean、ObjectFactory的区别</title>
      <link href="/2019/07/21/BeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/07/21/BeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这三个类都属于org.springframework.beans.factory包下，并且名字都有点相似，但在功能上却大部相同。具体有哪些不同呢？下面将从这三个类的功能与用法分别分析。</p></blockquote><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><blockquote><p>该类名以Factory结尾，其实质为一个Bean工厂接口，源码如下。从源码可以看出这个接口定义了Bean工厂的一些基本操作。所以这个接口起到了规范Bean工厂的基本操作作用。其基本实现有HierarchicalBeanFactory、ListableBeanFactory和ConfigurableBeanFactory以及各种ApplicationContext等等。如果想看BeanFactory的基本实现可以去看ListableBeanFactory的源码。而BeanFactory的使用则推荐使用ApplicationContext的一些派生类（如FileSystemXmlApplicationContext以及AnnotationConfigApplicationContext等类）</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>; <span class="comment">// 这个与FactoryBean有关，后面会介绍到</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>; <span class="comment">//是否是多例的意思</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name); <span class="comment">// 获取Bean的别名</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><blockquote><p>该类以Bean结尾，自然就是一个Bean，但这个Bean不是普通的Bean。这个Bean的设计类似于工厂模》&gt;式，专门用于创建特定的对象。可是Spring控制反转不是把对象的创建控制权交给了BeanFactory进行管理吗？那是因为有些创建比较复杂的类用配置文件来描述初始化不方便（Bean工厂要读取xml或者注解形式的类的初始化相关属性，这样Bean工厂才知道怎么帮我们创建该对象）。源码如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getObject方法便是这个FactoryBean创建对象的地方。调用这个方法就可以获取他创建的一个对象。</p><blockquote><p>使用方法（本次只展示xml方式）</p></blockquote><p>展示中涉及三个类<br><br>Test类：main方法<br><br>Car类：FactoryBean中构建的。<br><br>CarFactoryBean类：继承了FactoryBean专用来构建Car的。</p><blockquote><p>Car</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm Car"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CarFactoryBean在getObject方法中构建Car对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//FactoryBean专门用来创建初始化复杂的对象</span></span><br><span class="line">        <span class="comment">//此处假设在进行很复杂的构造对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm CarFactory"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置文件beans.xml。 注意此处name为bean对应的是CarFactoryBean,等下注意使用getBean方法获取的对象是什么。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"com.test.CarFactoryBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Test</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Object obj1 = ctx.getBean(<span class="string">"car"</span>);</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        Object obj2 = ctx.getBean(<span class="string">"&amp;car"</span>);<span class="comment">// 注意这里的区别</span></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后输出的结果如下</p></blockquote><p><img src="https://user-images.githubusercontent.com/33340562/61588886-352c7300-abd5-11e9-90f7-1ac0d1818130.png" alt="image"></p><p>所以大家发现了没，在配置文件中我们配置的是car对应CarFactoryBean对象的，但是在getBean(“car”)时，取到的却是Car对象。这正是FactoryBean作用之处，在getBean中自动的调用了FactoryBean的getObject方法，并将FactoryBean构建的对象返回。如果想得到的是CarFactoryBean对象呢？那就要在car前面加个&amp;符号(心细的同学可能记得前面BeanFactory源码中也提到了&amp;符号，其作用就是这个）。</p><blockquote><p>通过Debug看源码可以看出在AbstractBeanFactory类中的getObjectForBeanInstance方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否实现了FactoryBean接口，</span></span><br><span class="line">    <span class="comment">//如果没实现就返回bean对象。</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果实现了FactoryBean对象</span></span><br><span class="line">        <span class="comment">//则从FactoryBean中调用getObject方法获取对象</span></span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h1><blockquote><p>跟FactoryBean一样，用工厂模式创建对象。源码如下。<br>那么竟然与FactoryBean类似，都是用于创建对象。那两者有什么区别呢？<br>我们注意到FactoryBean中还具有isSingleton、getObjectType等方法。<br>这些方法是专门用于bean工厂的。从这个接口的注释也可以得出FactoryBean是专为BeanFactory所设计（This interface is similar to {@link FactoryBean}, but implementations<br> of the latter are normally meant to be defined as SPI instances in a {@link BeanFactory}）。因此ObjectFactory只是一个普通的工厂模式中的工厂接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defines a factory which can return an Object instance</span></span><br><span class="line"><span class="comment"> * (possibly shared or independent) when invoked.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is typically used to encapsulate a generic factory which</span></span><br><span class="line"><span class="comment"> * returns a new instance (prototype) of some target object on each invocation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is similar to &#123;<span class="doctag">@link</span> FactoryBean&#125;, but implementations</span></span><br><span class="line"><span class="comment"> * of the latter are normally meant to be defined as SPI instances in a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanFactory&#125;, while implementations of this class are normally meant</span></span><br><span class="line"><span class="comment"> * to be fed as an API to other beans (through injection). As such, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> getObject()&#125; method has different exception handling behavior.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Colin Sampaleanu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FactoryBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance (possibly shared or independent)</span></span><br><span class="line"><span class="comment"> * of the object managed by this factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean (should never be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/06/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/06/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机常见英语单词翻译</title>
      <link href="/2019/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云环境下配置Nginx的SSL证书</title>
      <link href="/2019/04/04/%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6/"/>
      <url>/2019/04/04/%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云服务器Nginx环境下配置SSL证书"><a href="#阿里云服务器Nginx环境下配置SSL证书" class="headerlink" title="阿里云服务器Nginx环境下配置SSL证书"></a><center>阿里云服务器Nginx环境下配置SSL证书</center></h1><h2 id="HTTPS的认识"><a href="#HTTPS的认识" class="headerlink" title="HTTPS的认识"></a>HTTPS的认识</h2><p>### </p><blockquote><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></blockquote><p>&#8194;&#8194;一般我们的服务器默认使用http协议，而https协议则需要自己配置协议，所以当在浏览器输入栏输入域名前加https时，会显示无法访问（如图1-1所示)。所以本次我将记录下在阿里云服务器Nginx环境下配置https协议过程。如在其他云运行商，亦可参考。<br><a id="more"></a></p><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041349_337.png" alt="图1-1  没配置ssl证书时https访问无效"></p><h2 id="第一步：下载SSL证书"><a href="#第一步：下载SSL证书" class="headerlink" title="第一步：下载SSL证书"></a>第一步：下载SSL证书</h2><p><br></p><blockquote><p>SSL证书分为收费版和免费的，作为一个土豆丝，我只能申请免费版的ssl证书，为期一年，但是可以无限申请。至于在哪里下呢。请按如下步骤。</p></blockquote><h3 id="进入域名的云解析控制台"><a href="#进入域名的云解析控制台" class="headerlink" title="进入域名的云解析控制台"></a>进入域名的云解析控制台</h3><blockquote><p>（当然，前提是咱们有个域名）界面如图（2-1）所示<br> 在你要配置SSL证书的那一项点击旁边的更多，然后又一个SSL证书按钮（如图2-2），点击它。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041401_326.png" alt="图2-1  云解析控制台"><br><img src="http://ppf89if8g.bkt.clouddn.com/201904041404_248.png" alt="图2-2"></p><h3 id="申请Symantec-DV-SSL证书"><a href="#申请Symantec-DV-SSL证书" class="headerlink" title="申请Symantec DV SSL证书"></a>申请Symantec DV SSL证书</h3><blockquote><p>在阿里云平台中该证书是免费的，但是期限只有一年，一年后过期可再来申请。<br>如图2-3填写要申请的域名，刚开始我输入*想为所有二级域名配置ssl证书，但是发现申请的按钮是灰的。后来发现输入www则没事，输入别的应该也可以吧，大家可以试试。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041408_734.png" alt="图2-3"></p><h3 id="填写验证信息"><a href="#填写验证信息" class="headerlink" title="填写验证信息"></a>填写验证信息</h3><blockquote><p>大家在这里可能会遇见图2-4这种错误，但是大家不要方。<br>刚开始我也遇见了，后来发现他是在域名解析规则中添加了一个主机记录为_dnsauth的解析规则。<br>而域名解析规则更新到dns服务器上要等一会儿，所以大家乘这个机会喝杯茶，等下点击验证就ojbk。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041411_993.png" alt="图2-4"></p><h3 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h3><blockquote><p>上一步验证成功后，就会跳转到SSL证书下载页面（如图2-5）。大家根据自己的需求下载对应的证书就可以了，我是要配置Nginx的SSL证书所以这里我选择了Nginx版的。到此第一阶段就结束了。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041413_941.png" alt="图2-5"></p><h2 id="第二步：配置Nginx"><a href="#第二步：配置Nginx" class="headerlink" title="第二步：配置Nginx"></a>第二步：配置Nginx</h2><h3 id="将证书上传服务器"><a href="#将证书上传服务器" class="headerlink" title="将证书上传服务器"></a>将证书上传服务器</h3><blockquote><p>我先将下载的压缩包解压开，然后里面会有一个pem和key文件。然后通过scp命令（命令如下）将该软件上传到服务器的Nginx配置文件夹中的一个文件夹(SSL文件夹，这个文件夹是我自己建的，大家可以上传到自己喜欢的目录中)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r 2020586_www.butong.live.key 2020586_www.butong.live.pem root@www.butong.live:/etc/nginx/ssl</span><br><span class="line">//格式</span><br><span class="line">scp -r 文件[ 文件] 用户名@域名或ip:/上传到的文件夹</span><br></pre></td></tr></table></figure><h3 id="修改nginx-conf文件"><a href="#修改nginx-conf文件" class="headerlink" title="修改nginx.conf文件"></a>修改nginx.conf文件</h3><blockquote><p>在server中添加以下几行代码（以下代码可与原来的配置http代码共存，所以无需删除之前http的配置）<br>然后保存退出运行 nginx -s reload命令重启Nginx即可。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate ssl/2020586_www.butong.live.pem; # 你解压开的文件放在的目录</span><br><span class="line">    ssl_certificate_key ssl/2020586_www.butong.live.key; # 你解压开的文件放在的目录</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    、、、 # 后面的保持原来的配置文件不变即可</span><br></pre></td></tr></table></figure><blockquote><p>以上就是在阿里云环境下配置Nginx的ssl证书的完整过程。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS协议 </tag>
            
            <tag> SSL证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>error 与 exception的区别</title>
      <link href="/2019/02/24/error-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/02/24/error-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a><center>Error与Exception的区别</center></h1><hr><h2 id="同"><a href="#同" class="headerlink" title="同"></a>同</h2><blockquote><p>1:两者都继承自Throwable</p></blockquote><h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><blockquote><p>1: 可以是可被控制或不可控制(例如RuntimeException异常及其子类);<br>         注:可控不可控就看在代码编写时能否检测到异常;<br>2: 表示有一个程序员导致的错误;<br>3: 应该在应用级被处理;</p></blockquote><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote><p>1: 总是不可控的（即在编译期不可探测到异常;<br>2: 常用来表示系统错误;<br>3: 应该在系统级被捕获;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
