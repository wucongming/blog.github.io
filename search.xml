<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AtomicXXX源码（一）]]></title>
    <url>%2F2019%2F10%2F19%2FAtomicXXX%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言本篇将会介绍AtomicBoolean、AtomicInteger、AtomicLong这三个原子类 作用这三个类是为了实现其对应类线程安全的一些操作。例如i++问题，这行代码包括三个步骤：读取i，将值+1，写入i。在执行这三个步骤的过程中，i都有可能被其他线程修改。那最终将会导致i的值出错。我们将这种问题称为状态依赖。状态依赖：变量下一个值依赖于前一个值，例如i = 5, i++; 最后i是多少，依赖于i初始值，这里i = 5,所以最终i = 6。 解决i++线程不安全问题AtomicInteger等三个类，为了解决i++类似的线程不安全问题，有两个核心点，一个是使用volatile保证值的可见性，另一个是CAS无锁式同步机制。其中CAS全称Compare and Swap（先比较再替换）。 源码分析初始化如果不清楚类的初始化顺序，请跳转☞。这三个类源码基本都是一样的，所以我把这三个类放一起记录。根据类的初始化顺序我们先看静态代码块 123456789private volatile int value;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125; 如上述代码，AntomicInteger中有个value变量，该变量使用volatile修饰。 为什么会用这个修饰呢？ 对于volatile大家都很熟悉，它能够保证变量的可见性，也就是当一个线程对变量a做出改变时，另一个变量能够立马发现变量a的变化。而我们AtomicInteger使用CAS需要比较然后替换，如果是跟一个旧值比较，那有何意义（这是一个需要大家思考的问题）。 然后代码块中会调用unsafe.objectFieldOffset方法，这个方法就是获取某个属性在类中的偏移地址。获取到这个偏移地址后，我们就可以根据内存地址直接修改其内存中的值了。 对于静态代码块执行之后的构造方法我就不做过多的解释了，因为其构造函数没什么有意义的东西。 1234567891011121314/** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */public AtomicInteger(int initialValue) &#123; value = initialValue;&#125;/** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */public AtomicInteger() &#123;&#125; 方法分析 常用的getAndIncrement方法 123456789101112131415161718// AtomicInteger中的方法public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;// UnSafe类中的方法/** * var1: AtomicInteger对象的地址 * var2: 对象中int值的偏移地址 * var4: AtomicInteger中int变量的变化量 */public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 上述代码是一种典型的CAS自旋锁，所谓的自旋锁就是在别人修改的时候，自己一直循环访问是否能修改值，而不会被阻塞直到资源占用着释放资源才被唤醒。在上面的代码中，UnSafe的compareAndSwapInt是调用了C语言的原生代码。在compareAndSwapInt中，会进行比较。如果内存中的值跟预期的var5一样，则返回true，否则返回false直到内存中的值与预期的var5一样，才将var5 + var4写入内存中。 疑问 如果内存中的值与我们预期的var5一样，然后开始准备写入我们的var5 + var4时，内存中的值被人修改了怎么办？会发生这种情况吗？（这句话的意思能体会吗） 如果会发送图中的情况，那么AtomicInteger将不是线程安全的类。经过查找网上大家都说比较并替换是由硬件完成的，而这个操作是不会响应中断，所以保证了它的原子性。 IntUnaryOperator类 123456789101112131415161718/** * Atomically updates the current value with the results of * applying the given function, returning the previous value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the previous value * @since 1.8 */public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev;&#125; 在AtomicInteger类中，只是定义了getAndIncrement和getAndDecrement等简单的操作。但是还有很多复杂的并且依赖之前的值的操作，比如value = value / 2等等，不可能全部实现在类中。所以AtomicInteger提供了一些函数接口，例如IntUnaryOperator用户实现该接口，并且在其中进行一些复杂的操作来完成需求。 简单的使用 1234567891011121314151617181920public class IntUnaryOperatorTest &#123; public static void main(String[] args) &#123; AtomicInteger num = new AtomicInteger(0); System.out.println(num.getAndUpdate(new Operator())); System.out.println(num.getAndUpdate(v -&gt; v * 100)); // lambda表达式写法， java8中的函数接口都可以用lambda表达式 &#125; &#125;class Operator implements IntUnaryOperator &#123; @Override public int applyAsInt(int operand) &#123; System.out.println("Hello----------------applyAsInt"); return operand + 100; &#125; &#125; compareAndSet和weakCompareAndSet 12345678910111213141516171819202122232425262728/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */public final boolean compareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update);&#125;/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful */public final boolean weakCompareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update);&#125; 在weakCompareAndSet注释中说，weakCompareAndSet不保证指令不会重排序，而且可能会替换失败。但是其调用的代码与compareAndSet一模一样，所以我猜测这个在功能上与compareAndSet，并未实现像其注释说的一样。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[concurrent包源码阅读开篇]]></title>
    <url>%2F2019%2F10%2F16%2Fconcurrent%E5%8C%85%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言前段时间认识了一个从事深度学习方向的博士学长，这个学长帮导师写一个项目临时要用java做开发。学长由于不太会java就问了我一个并发框架的问题，可是我这个声称是学java的却回答不上来。顿时觉得有种没学过java的感觉，为了以后不会发生这种尴尬，遂决心阅读concurrent包中的源码，并以此系列作为笔记。 并发面临的问题并发中常遇见的问题有原子性问题、可见性问题。其中由于jvm对代码的优化还带来了有序性问题。 原子性现代电脑处理器基本有多个内核，而每个内核上可以跑一个线程，所以电脑可以实现真正的并行运算。而两个并行运算的线程难免有所交集处理了一个变量。就如下面的情况，这样线程A得到的值最后竟然是0。有时候出现这种情况是致命性的，所以为了避免这种情况发送我们要确保对变量a进行处理和赋值的过程是原子性的，不能被中断。 在java中如果要实现原子性可以对操作进行加锁，例如使用synchronized和Lock。同过这些锁，可以使一个代码块或者对象只能被一个线程使用，其他线程只能等使用者用完。 可见性在java的线程内存模型中，线程会共享本进程分配得到的内存。而每个线程会有属于自己的工作内存（工作内存线程之间不共享），他们会把一些共享变量拷贝到自己的工作内存。对共享变量进行操作时，会首先对自己工作内存进行操作，所以线程a看不到线程b对共享变量的操作，除非将线程b的工作内存刷新到主内存中，线程a才能看到（什么时候刷新我不太清楚，知道的大佬可以教教我）。 正是因为线程a可能看不到线程b对变量的改变，就产生了变量的可见性问题。例如可以执行如下代码：12345678910111213141516171819202122public class Main &#123; static boolean flag = true; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while(flag) &#123; &#125; System.out.println(Thread.currentThread() + "中的循环结束了"); &#125; &#125;, "检测Flag的线程").start(); Thread.sleep(1000); flag = false; System.out.println("flag的值为" + flag); &#125;&#125; 解决共享变量的可见性问题就是使用volatile。具体详情可以参考https://www.cnblogs.com/monkeysayhi/p/7654460.html可以将class文件反编译成汇编语言进行验证。 下期，将会写读并发包源码的笔记]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2019%2F09%2F24%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 假设系统中存在一个对象A被频繁的创建。如果某一天，需求发生变化，我们要重新改变对象A的创建的时候，发现A在几十个甚至上百个java文件中创建了。我们该怎么办？一个一个修改吗？ 当我们遇见这种经常使用的对象时，就该想想是否是要用到工厂模式了。为了少加班做无用功，让我们看看工厂模式是怎么解决这种问题的。 假设背景假设我们刚开始时建一个只有高度和宽度的手机类。然后创建N个手机类对象。突然，产品锦鲤要我们给手机类加上颜色属性。 未用工厂模式刚开始建的手机类 123456789101112131415161718192021/** * 未上色的手机类 */public class Phone &#123; private int width; private int height; public Phone(int width, int height) &#123; this.width = width; this.height = height; &#125; @Override public String toString() &#123; return "Phone&#123;" + "width=" + width + ", height=" + height + '&#125;'; &#125;&#125; 手机类建好了，我们开始生产手机把 123456789101112public class Main &#123; public static void main(String[] args) &#123; Phone phone1 = new Phone(15,10); Phone phone2 = new Phone(15,10); Phone phone3 = new Phone(15,10); Phone phone4 = new Phone(15,10); Phone phone6 = new Phone(15,10); Phone phone7 = new Phone(15,10); Phone phone8 = new Phone(15,10); &#125;&#125; 生产了一批没上色的手机，这个时候，产品锦鲤要求手机要加个颜色属性，并且构建的时候就要初始化。加吧。 1234567891011121314151617181920212223/** * 上色的手机类 */public class Phone &#123; private int width; private int height; private String color; public Phone(int width, int height, String color) &#123; this.width = width; this.height = height; this.color = color; &#125; @Override public String toString() &#123; return "Phone&#123;" + "width=" + width + ", height=" + height + '&#125;'; &#125;&#125; 可是回头看Main方法（生产手机的地方） 发现使用之前构造手机的方法不行了，我们要把它们一个一个加上颜色。在这里我们还只是用了8次而且都在一个文件中。如果真的在开发环境中，一个类用了几十次，并且都分布在不同的文件中，突然发现要给类加东西怎么办？ 所以在项目中发现存在这种对象存在，就要考虑是否要用工厂模式来生产该对象了。下面我们看看使用简单工厂模式。 简单工厂模式我们先用只有高度和宽度属性的手机类，然后在简单工厂模式创建手机类 12345public class PhoneFactory &#123; public static Phone createPhone() &#123; return new Phone(10, 15); &#125;&#125; 在主方法中使用PhoneFactory创建Phone对象 1234567891011public class Main &#123; public static void main(String[] args) &#123; Phone phone = PhoneFactory.createPhone(); Phone phone1 = PhoneFactory.createPhone(); Phone phone2 = PhoneFactory.createPhone(); Phone phone3 = PhoneFactory.createPhone(); Phone phone4 = PhoneFactory.createPhone(); &#125;&#125; 然后我们给Phone类加上颜色属性。这个时候我们发现PhoneFactory中创建Phone报错，但是主方法中由于未直接使用Phone的构造方法，所以当Phone的构造方法发生改变时，主方法也不会报错。这样整个项目就只有PhoneFactory一处报错，我们就很容易修改。 修改如下 123456public class PhoneFactory &#123; public static Phone createPhone() &#123; return new Phone(10, 15, "黑色"); &#125;&#125; 问题 但是使用简单工厂模式有几个缺点： 不符合开闭原则。 当我们需要添加新的类由工厂创建的时候，我们需要修改原来的PhoneFactory类。 臃肿 当PhoneFactory类中加入了大量的创建对象方法后，PhoneFactory会变得及其臃肿。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象方法模式]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 现实生活中，许多事务的处理步骤是固定的，但是每步详细的处理方法可能不尽相同。 例如：我们在外面回家时就要经历两个步骤。 第一步：买车票 第二步：坐车 假如我们不使用抽象方法模式写一个乘坐火车（Train）和乘坐大巴（bu）回家的流程： 123456789101112131415161718/** * 坐大巴回家 */public class GoHomeByBus &#123; public void buyTicket() &#123; System.out.println("去汽车站买汽车票"); &#125; public void sitCar() &#123; System.out.println("去汽车站坐车"); &#125; public void goHome() &#123; buyTicket(); sitCar(); &#125;&#125; 1234567891011121314151617/** * 坐火车回家 */public class GoHomeByTrain &#123; public void buyTicket() &#123; System.out.println("去火车站买火车票"); &#125; public void sitCar() &#123; System.out.println("去火车站坐车"); &#125; public void goHome() &#123; buyTicket(); sitCar(); &#125;&#125; 冗余问题 会发现我们在两种回家的类中都写了goHome方法，而且由于回家的流程一样，所以该方法的内容都一样，如果还需要添加其他的回家方式，就会造成了更多冗余。 解决冗余 所以我们可以提取一个GoHome类，将goHome方法写在GoHome类中，然后让描述不同回家方式的类继承GoHome，那么就很好解决了冗余的问题。 因为我们要将goHome方法写在GoHome类中，而goHome调用的方法在GoHome类中不存在，所以我们也要将其调用的方法上升到GoHome类中。而这几个方法是与回家方式相关的，所以将它们声明为abstract方法，让子类去实现。 UML图 具体代码 回家抽象类 1234567891011121314151617public abstract class GoHome &#123; /** * 买车票 */ public abstract void buyTicket(); /** * 坐车回家 */ public abstract void sitCar(); public void goGome() &#123; buyTicket(); sitCar(); &#125;&#125; 坐火车回家类 123456789101112public class GoHomeByTrain extends GoHome &#123; @Override public void buyTicket() &#123; System.out.println("去火车站买火车票"); &#125; @Override public void sitCar() &#123; System.out.println("去火车站坐车"); &#125;&#125; 坐大巴回家类1234567891011public class GoHomeByBus extends GoHome &#123; @Override public void buyTicket() &#123; System.out.println("去汽车站买汽车票"); &#125; @Override public void sitCar() &#123; System.out.println("去汽车站坐车"); &#125;&#125; 总结上面提出一个GoHome基类的实现方式就是利用抽象方法模式，抽象方法模式的核心思想就是将一件事的固定处理步骤的实现提取到基类中（如goHome方法），然后子类继承积累，并且子类只需要实现各个步骤的处理方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的函数接口]]></title>
    <url>%2F2019%2F09%2F06%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[前言在看spring源码路径解析的时候，遇见了helper.replacePlaceholders(text, this::getPropertyAsRawString);。这里有个很奇怪的this::getPropertyAsRawString。::这个符号在C++中很眼熟，但是在java中还是第一次见（是我太菜没怎么学过java8，后面一定要补上。先在此记录。）,也不知道传了什么东西过去。 在好奇心的促使下，我点进了方法replacePlaceholders发现参数列表为1234public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) &#123; Assert.notNull(value, "'value' must not be null"); return parseStringValue(value, placeholderResolver, null);&#125; 发现第二个参数是PlaceholderResolver类型，而这个类型是一个FunctionalInterface接口，其源码如下： 1234567891011121314/** * Strategy interface used to resolve replacement values for placeholders contained in Strings. */@FunctionalInterfacepublic interface PlaceholderResolver &#123; /** * Resolve the supplied placeholder name to the replacement value. * @param placeholderName the name of the placeholder to resolve * @return the replacement value, or &#123;@code null&#125; if no replacement is to be made */ @Nullable String resolvePlaceholder(String placeholderName);&#125; 问题：FunctionalInterface注解作用如这个注解的名字所示，这个接口只是向大家声明该接口是一个函数接口。而声明为函数接口，有如下要求： 只能有一个抽象函数(但是有例外，详情见下)。 可以有default修饰的方法，因为default修饰的方法是已经实现了的 函数接口中抽象函数可以有多个，但是除了自定义的抽象函数之外的抽象函数必须是Object中已实现的方法。（如：下面的代码） 12345678910111213@FunctionalInterfacepublic interface PlaceholderResolver &#123; String resolvePlaceholder(String placeholderName); default void print() &#123; System.out.println("hh "); &#125; public String toString(); public boolean equals(Object obj);&#125; 如果不是Object中已经实现的方法，则会报错。如下图： 知道函数接口的定义后，那函数接口怎么使用呢？以及他的作用 使用步骤定义一个函数接口12345@FunctionalInterfacepublic interface PlaceholderResolver &#123; String resolvePlaceholder();&#125; 定义一个将函数接口作为参数的方法123public void test(PlaceholderResolver placeholderResolver) &#123; placeholderResolver.resolvePlaceholder();&#125; 在定义一个方法1234public String print() &#123; System.out.println("我是print方法") return str;&#125; 现在就可以愉快的使用了123public void test() &#123; test(this::print);&#125; 而上面调用test方法后就会输出在执行placeholderResolver.resolvePlaceholder(“啦啦啦”);时输出我是print方法。其作用也就是将print方法赋给PlaceholderResolver中的resolvePlaceholder，所以在调用resolvePlaceholder方法会执行print。 最后究其到底函数接口只是一个语法糖，它是java8一个新的语法糖。它的效果等价于： 1234567public void test() &#123; test(new PlaceholderResolver() &#123; public String resolvePlaceholder() &#123; print(); &#125; &#125;)&#125; 所以在调用resolvePPlaceholder方法时会调用print方法。这样使用函数接口替代匿名内部类，可以是代码更加简洁。但要注意的是print方法要和resolvePlaceholder方法的参数列表、返回参数一致，方法名可以不一致。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant风格]]></title>
    <url>%2F2019%2F09%2F01%2FAnt%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言在阅读dalao的文章时，看到支持Ant风格。遂对Ant风格产生了好奇。遂写此blog以做笔记。 Ant风格：就是匹配路径和url的一种规则。例如：我们常见的C:/project/*.html匹配C盘目录下project文件夹中的所有html文件。 规则 符号 说明 ? 匹配任何单字符 * 匹配0或者任意数量的字符 ** 匹配0或者更多的目录 例如URL路径 | 说明–|–:/project/.a|匹配项目根路径下所有在project路径下的.a文件/project/p?ttern|匹配项目根路径下 /project/pattern 和 /app/pXttern,但是不包括/app/pttern//example|匹配项目根路径下 /project/example, /project/foow/example, 和 /example/project//dir/file.|匹配项目根路径下/project/dir/file.jsp, /project/foow/dir/file.html,/project/foow/bar/dir/file.pdf/*/.jsp|匹配项目根路径下任何的.jsp 文件 注意：如果一个路径存在多个匹配，那么将选择最长的匹配。例如：URL请求/project/dir/file.jsp，现在存在两个路径匹配模式/*/.jsp和/project/dir/.jsp，那么会根据模式/project/dir/.jsp来匹配]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[schemaLocation值必须具有偶数个URI]]></title>
    <url>%2F2019%2F09%2F01%2FschemaLocation%E5%80%BC%E5%BF%85%E9%A1%BB%E5%85%B7%E6%9C%89%E5%81%B6%E6%95%B0%E4%B8%AAURI%2F</url>
    <content type="text"><![CDATA[前言学习并使用spring框架开发已经有了一段很长的时间了，但是之前没有把在学习过程中遇见关于spring的错误积累下来。所以从现在开始，将在此开辟一博客收集我遇见的奇葩错误。 错误一 SchemaLocation: schemaLocation 值必须具有偶数个 URI 该错误是我在学习ignoreDependencyInterface和ignoreDependencyType之间的区别及使用的时候发现的。 我在配置spring的beans.xml时，设置context:annotation-config&lt;/context:annotation-config&gt;。发现要在beans标签中加入xmlns:context=”http://www.springframework.org/schema/context&quot;。（因为我们要用到context标签所以要引入context） 加入后运行。 代码提示报错 12345678910111213141516Exception in thread "main" org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 52 in XML document from file [C:\Users\Administrator\Downloads\adaptive-loadbalance-master-154377df0a8f753f2ea462ec15a6f76f882691bc\study\src\main\resources\META-INF\spring\camel-context.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 52; columnNumber: 30; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 'context:annotation-config' 的声明。 at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:404) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:336) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:195) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:257) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:128) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:94) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:133) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:636) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:521) at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:142) at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:85) at study.Application.main(Application.java:11) 原因是因为在12xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd" 中要加入12http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 刚开始年轻的我只加入了一个1http://www.springframework.org/schema/context 导致报错1org.xml.sax.SAXParseException: SchemaLocation: schemaLocation 值 'http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd http://www.springframework.org/schema/context' 必须具有偶数个 URI。 总结通过这次错误，我们可以知道要在beans.xml中加入一个标签的流程如下（以context为例）： 第一步：加入1xmlns:context="http://www.springframework.org/schema/context" 第二步：在xsi:schemaLocation中加入1http://www.springframework.org/schema/context 第三步：在xsi:schemaLocation中加入1http://www.springframework.org/schema/spring-context.xsd]]></content>
      <categories>
        <category>错误</category>
      </categories>
      <tags>
        <tag>spring错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuffer神秘的toStringCache属性]]></title>
    <url>%2F2019%2F08%2F17%2FStringBuffer%E7%A5%9E%E7%A7%98%E7%9A%84toStringCache%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言 大家都知道直接对String字符串进行拼接等操作时，会创建大量的String对象。因此用String直接进行这些操作效率会很低。所以催生了StringBuilder和StringBuffer这两个类。这两个类基本相同，但是StringBuffer多了一个toStringCache变量（后面具体讲解该变量作用），并在方法体上加了synchronized。 StringBuilder和StringBuffer的相同点 都继承于AbstractStringBuilder类。 都实现了java.io.Serializable, CharSequence接口。 字符串都是存储在一个字符数组中。StringBuilder和StringBuffer不同点一 StringBuffer是线程安全的，而StringBuilder是线程不安全的。那StringBuffer是怎么实现线程安全的呢？通过源码的对比，可以看到两个类的实现大致相同，不一样的就是StringBuffer在方法体加了synchronized。 StringBuilder和StringBuffer不同点二 在对比两个类的源码，发现StringBuffer多了一个toStringCache12345/** * A cache of the last value returned by toString. Cleared * whenever the StringBuffer is modified. */ private transient char[] toStringCache; 这个属性的作用是缓存toString方法返回的最后一个值，当StringBuffer对象被修改时，这个变量都会被设置为NULL。 toStringCache的作用 众所周知对字符串的操作效率StringBuilder &gt; StringBuffer &gt; String也就是说StringBuffer的效率并不是最棒的，所以仍需提高，设置toStringCache的作用就是为了提高效率 问题来了：toStringCache是怎么提高效率的 先看看StringBuilder和StringBuffer两个类中的toString方法 StringBuffer的toString方法1234567@Overridepublic synchronized String toString() &#123; if (toStringCache == null) &#123; toStringCache = Arrays.copyOfRange(value, 0, count); &#125; return new String(toStringCache, true);&#125; StringBuilder的toString方法12345@Overridepublic String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count);&#125; 从两个方法中可以看到StringBuffer已经将方法重写为了synchronized方法，已经实现了线程安全，可是方法的具体实现却不同。 两个方法创建String的方法分别为： new String(toStringCache, true); –对应的构造方法–&gt; String(char[] value, boolean share)new String(value, 0, count); –&gt;对应的构造方法–&gt; String(char value[], int offset, int count) 所以现在需要去了解两个构造方法的不同 12345678910111213public String(char value[], int offset, int count) &#123; //此处省略一部分代码 ...... this.value = Arrays.copyOfRange(value, offset, offset+count); //复制数组到value &#125;&#125;//完整的函数，就是这么简单粗暴String(char[] value, boolean share) &#123; // assert share : "unshared not supported"; this.value = value;&#125; 从上面可以看出调用String(char[] value, boolean share) 不用复制数组调用String(char value[], int offset, int count) 需要复制数组 再回到StringBuffer和StringBuilder的toString方法就知道StringBuffer只有当toStringCache是NULL的时候（也就是当字符串发生变化）需要复制数组，而StringBuilder的toString方法每次创建String都要复制数组。所以现在清楚了toStringCache就是这样提高一点点效率。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的生命周期]]></title>
    <url>%2F2019%2F07%2F22%2FSpring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[我们都知道Spring的IOC容器帮我们管理着Bean，我们可以从IOC容器中拿到我们想要的Bean对象。但是IOC是如何管理我们的Bean呢？下面将会从源码分析的角度来介绍Spring中Bean的生命周期。 BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解) 12345678910111213141516171819202122232425/** * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is:&lt;br&gt; * 1. BeanNameAware's &#123;@code setBeanName&#125;&lt;br&gt; * 2. BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;&lt;br&gt; * 3. BeanFactoryAware's &#123;@code setBeanFactory&#125;&lt;br&gt; * 4. ResourceLoaderAware's &#123;@code setResourceLoader&#125; * (only applicable when running in an application context)&lt;br&gt; * 5. ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125; * (only applicable when running in an application context)&lt;br&gt; * 6. MessageSourceAware's &#123;@code setMessageSource&#125; * (only applicable when running in an application context)&lt;br&gt; * 7. ApplicationContextAware's &#123;@code setApplicationContext&#125; * (only applicable when running in an application context)&lt;br&gt; * 8. ServletContextAware's &#123;@code setServletContext&#125; * (only applicable when running in a web application context)&lt;br&gt; * 9. &#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors&lt;br&gt; * 10. InitializingBean's &#123;@code afterPropertiesSet&#125;&lt;br&gt; * 11. a custom init-method definition&lt;br&gt; * 12. &#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors * * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;br&gt; * 1. DisposableBean's &#123;@code destroy&#125;&lt;br&gt; * 2. a custom destroy-method definition **/ 注释翻译（翻译错的请轻喷）Bean工厂的实现者应该尽可能支持标准的Bean生命周期接口。Bean的初始化方法和他们标准的执行顺序如下：1.BeanNameAware的setBeanName方法2.BeanClassLoaderAware的setBeanClassLoader方法3.BeanFactoryAware的setBeanFactory方法4.ResourceLoaderAware的setResourceLoader方法5.ApplicationEventPublisherAware的setApplicationEventPublisher方法6.MessageSourceAware的setMessageSource方法7.ApplicationContextAware的setApplicationContext方法8.ServletContextAware的setServletContext方法9.BeanPostProcessors的postProcessAfterInitialization方法初始化完毕 -&gt; 进行我们的业务操作Bean的关闭生命周期调用方法1.DisposableBean的destroy方法2.在配置文件中指定的destroy-method方法 看完这个注释后，我们将回到源码找到Bean执行以上方法的地方。通过调试我们可以找到执行上述步骤的方法为initializeBean方法。123456789101112131415161718192021222324252627282930protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 上面的代码就为该方法，我将该方法分为四部分。 第一部分执行所有的Aware方法也就是上面提到的invokeAwareMethods方法该方法将XXXAware对应的XXX对象传给bean。例如BeanNameAware就会将beanName传给bean。12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 第二部分执行Bean后置处理器的postProcessBeforeInitialization方法Bean后置处理器也就是BeanPostProcessor的实现类。也就是initializeBean方法中applyBeanPostProcessorsBeforeInitialization调用。在applyBeanPostProcessorsBeforeInitialization方法中，Spring将遍历执行系统自带的和用户定义的所有Bean后置处理器。12345678910public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 第三部分执行Bean的Init方法在这里首先会判断Bean是否继承了InitializingBean接口如果继承了InitializingBean接口，就调用InitializingBean接口的afterPropertiesSet方法。然后判断用户在配置Bean的时候是否指定了init方法（xml配置为指定init-method，注解配置为PostConstruct）。如果指定了就调用。123456789101112131415161718192021222324252627282930313233protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'"); &#125; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; if (mbd != null) &#123; String initMethodName = mbd.getInitMethodName(); if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; "afterPropertiesSet".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125;&#125; 第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步 到此Bean的初始化就完成了。后面就是Bean的销毁销毁跟初始化调用Bean的init方法一样，不过在销毁的时候是判断Bean是否实现了DisposableBean接口，如果实现了就调用DisposableBean的destroy方法。然后在判断Bean是否指定了销毁方法（xml方式是destroy-method，注解方式是@PreDestroy） 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void destroy() &#123; if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123; for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123; processor.postProcessBeforeDestruction(this.bean, this.beanName); &#125; &#125; if (this.invokeDisposableBean) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking destroy() on bean with name '" + this.beanName + "'"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((DisposableBean) bean).destroy(); return null; &#125; &#125;, acc); &#125; else &#123; ((DisposableBean) bean).destroy(); &#125; &#125; catch (Throwable ex) &#123; String msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'"; if (logger.isDebugEnabled()) &#123; logger.warn(msg, ex); &#125; else &#123; logger.warn(msg + ": " + ex); &#125; &#125; &#125; if (this.destroyMethod != null) &#123; invokeCustomDestroyMethod(this.destroyMethod); &#125; else if (this.destroyMethodName != null) &#123; Method methodToCall = determineDestroyMethod(); if (methodToCall != null) &#123; invokeCustomDestroyMethod(methodToCall); &#125; &#125;&#125; Bean的生命周期总结 调用XXXAware方法的setXXX–&gt;调用Bean后置处理器的postProcessBeforeInitialization–&gt;调用InitializingBean接口的afterPropertiesSet方法–&gt;调用用户指定的初始方法–&gt; 业务 –&gt;调用DisposableBean接口的destory方法–&gt;调用用户指定的销毁方法]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory、FactoryBean、ObjectFactory的区别]]></title>
    <url>%2F2019%2F07%2F21%2FBeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[这三个类都属于org.springframework.beans.factory包下，并且名字都有点相似，但在功能上却大部相同。具体有哪些不同呢？下面将从这三个类的功能与用法分别分析。 BeanFactory 该类名以Factory结尾，其实质为一个Bean工厂接口，源码如下。从源码可以看出这个接口定义了Bean工厂的一些基本操作。所以这个接口起到了规范Bean工厂的基本操作作用。其基本实现有HierarchicalBeanFactory、ListableBeanFactory和ConfigurableBeanFactory以及各种ApplicationContext等等。如果想看BeanFactory的基本实现可以去看ListableBeanFactory的源码。而BeanFactory的使用则推荐使用ApplicationContext的一些派生类（如FileSystemXmlApplicationContext以及AnnotationConfigApplicationContext等类） 1234567891011121314151617public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = "&amp;"; // 这个与FactoryBean有关，后面会介绍到 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; //是否是多例的意思 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); // 获取Bean的别名&#125; FactoryBean 该类以Bean结尾，自然就是一个Bean，但这个Bean不是普通的Bean。这个Bean的设计类似于工厂模》&gt;式，专门用于创建特定的对象。可是Spring控制反转不是把对象的创建控制权交给了BeanFactory进行管理吗？那是因为有些创建比较复杂的类用配置文件来描述初始化不方便（Bean工厂要读取xml或者注解形式的类的初始化相关属性，这样Bean工厂才知道怎么帮我们创建该对象）。源码如下。 123456789public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; getObject方法便是这个FactoryBean创建对象的地方。调用这个方法就可以获取他创建的一个对象。 使用方法（本次只展示xml方式） 展示中涉及三个类Test类：main方法Car类：FactoryBean中构建的。CarFactoryBean类：继承了FactoryBean专用来构建Car的。 Car 123456public class Car &#123; @Override public String toString() &#123; return "I'm Car"; &#125;&#125; CarFactoryBean在getObject方法中构建Car对象。 123456789101112131415161718192021class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; public Car getObject() throws Exception &#123; //FactoryBean专门用来创建初始化复杂的对象 //此处假设在进行很复杂的构造对象 return new Car(); &#125; public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; public boolean isSingleton() &#123; return false; &#125; @Override public String toString() &#123; return "I'm CarFactory"; &#125;&#125; 配置文件beans.xml。 注意此处name为bean对应的是CarFactoryBean,等下注意使用getBean方法获取的对象是什么。 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="bean" class="com.test.CarFactoryBean"/&gt;&lt;/beans&gt; Test 123456789public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); Object obj1 = ctx.getBean("car"); System.out.println(obj1); Object obj2 = ctx.getBean("&amp;car");// 注意这里的区别 System.out.println(obj2); &#125;&#125; 最后输出的结果如下 所以大家发现了没，在配置文件中我们配置的是car对应CarFactoryBean对象的，但是在getBean(“car”)时，取到的却是Car对象。这正是FactoryBean作用之处，在getBean中自动的调用了FactoryBean的getObject方法，并将FactoryBean构建的对象返回。如果想得到的是CarFactoryBean对象呢？那就要在car前面加个&amp;符号(心细的同学可能记得前面BeanFactory源码中也提到了&amp;符号，其作用就是这个）。 通过Debug看源码可以看出在AbstractBeanFactory类中的getObjectForBeanInstance方法 12345678910111213141516171819202122232425262728293031protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123; if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; //判断是否实现了FactoryBean接口， //如果没实现就返回bean对象。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; //如果实现了FactoryBean对象 //则从FactoryBean中调用getObject方法获取对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // Return bean instance from factory. FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; ObjectFactory 跟FactoryBean一样，用工厂模式创建对象。源码如下。那么竟然与FactoryBean类似，都是用于创建对象。那两者有什么区别呢？我们注意到FactoryBean中还具有isSingleton、getObjectType等方法。这些方法是专门用于bean工厂的。从这个接口的注释也可以得出FactoryBean是专为BeanFactory所设计（This interface is similar to {@link FactoryBean}, but implementations of the latter are normally meant to be defined as SPI instances in a {@link BeanFactory}）。因此ObjectFactory只是一个普通的工厂模式中的工厂接口。 1234567891011121314151617181920212223242526/** * Defines a factory which can return an Object instance * (possibly shared or independent) when invoked. * &lt;p&gt;This interface is typically used to encapsulate a generic factory which * returns a new instance (prototype) of some target object on each invocation. * &lt;p&gt;This interface is similar to &#123;@link FactoryBean&#125;, but implementations * of the latter are normally meant to be defined as SPI instances in a * &#123;@link BeanFactory&#125;, while implementations of this class are normally meant * to be fed as an API to other beans (through injection). As such, the * &#123;@code getObject()&#125; method has different exception handling behavior. * * @author Colin Sampaleanu * @since 1.0.2 * @see FactoryBean */public interface ObjectFactory&lt;T&gt; &#123; /** * Return an instance (possibly shared or independent) * of the object managed by this factory. * @return an instance of the bean (should never be &#123;@code null&#125;) * @throws BeansException in case of creation errors */ T getObject() throws BeansException;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F06%2F06%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机常见英语单词翻译]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>大杂烩</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云环境下配置Nginx的SSL证书]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[阿里云服务器Nginx环境下配置SSL证书HTTPS的认识### HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 &#8194;&#8194;一般我们的服务器默认使用http协议，而https协议则需要自己配置协议，所以当在浏览器输入栏输入域名前加https时，会显示无法访问（如图1-1所示)。所以本次我将记录下在阿里云服务器Nginx环境下配置https协议过程。如在其他云运行商，亦可参考。 第一步：下载SSL证书 SSL证书分为收费版和免费的，作为一个土豆丝，我只能申请免费版的ssl证书，为期一年，但是可以无限申请。至于在哪里下呢。请按如下步骤。 进入域名的云解析控制台 （当然，前提是咱们有个域名）界面如图（2-1）所示 在你要配置SSL证书的那一项点击旁边的更多，然后又一个SSL证书按钮（如图2-2），点击它。 申请Symantec DV SSL证书 在阿里云平台中该证书是免费的，但是期限只有一年，一年后过期可再来申请。如图2-3填写要申请的域名，刚开始我输入*想为所有二级域名配置ssl证书，但是发现申请的按钮是灰的。后来发现输入www则没事，输入别的应该也可以吧，大家可以试试。 填写验证信息 大家在这里可能会遇见图2-4这种错误，但是大家不要方。刚开始我也遇见了，后来发现他是在域名解析规则中添加了一个主机记录为_dnsauth的解析规则。而域名解析规则更新到dns服务器上要等一会儿，所以大家乘这个机会喝杯茶，等下点击验证就ojbk。 下载证书 上一步验证成功后，就会跳转到SSL证书下载页面（如图2-5）。大家根据自己的需求下载对应的证书就可以了，我是要配置Nginx的SSL证书所以这里我选择了Nginx版的。到此第一阶段就结束了。 第二步：配置Nginx将证书上传服务器 我先将下载的压缩包解压开，然后里面会有一个pem和key文件。然后通过scp命令（命令如下）将该软件上传到服务器的Nginx配置文件夹中的一个文件夹(SSL文件夹，这个文件夹是我自己建的，大家可以上传到自己喜欢的目录中) 123scp -r 2020586_www.butong.live.key 2020586_www.butong.live.pem root@www.butong.live:/etc/nginx/ssl//格式scp -r 文件[ 文件] 用户名@域名或ip:/上传到的文件夹 修改nginx.conf文件 在server中添加以下几行代码（以下代码可与原来的配置http代码共存，所以无需删除之前http的配置）然后保存退出运行 nginx -s reload命令重启Nginx即可。 12345678910server &#123; listen 443 ssl; ssl on; ssl_certificate ssl/2020586_www.butong.live.pem; # 你解压开的文件放在的目录 ssl_certificate_key ssl/2020586_www.butong.live.key; # 你解压开的文件放在的目录 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; 、、、 # 后面的保持原来的配置文件不变即可 以上就是在阿里云环境下配置Nginx的ssl证书的完整过程。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>HTTPS协议</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error 与 exception的区别]]></title>
    <url>%2F2019%2F02%2F24%2Ferror-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Error与Exception的区别 同 1:两者都继承自Throwable 不同Exception 1: 可以是可被控制或不可控制(例如RuntimeException异常及其子类); 注:可控不可控就看在代码编写时能否检测到异常;2: 表示有一个程序员导致的错误;3: 应该在应用级被处理; Error 1: 总是不可控的（即在编译期不可探测到异常;2: 常用来表示系统错误;3: 应该在系统级被捕获;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
