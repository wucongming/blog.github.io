<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[有趣的函数接口]]></title>
    <url>%2F2019%2F09%2F06%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[前言在看spring源码路径解析的时候，遇见了helper.replacePlaceholders(text, this::getPropertyAsRawString);。这里有个很奇怪的this::getPropertyAsRawString。::这个符号在C++中很眼熟，但是在java中还是第一次见（是我太菜没怎么学过java8，后面一定要补上。先在此记录。）,也不知道传了什么东西过去。 在好奇心的促使下，我点进了方法replacePlaceholders发现参数列表为123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) &#123; Assert.notNull(value, "'value' must not be null"); return parseStringValue(value, placeholderResolver, null);&#125;``` 发现第二个参数是&lt;code&gt;PlaceholderResolver&lt;/code&gt;类型，而这个类型是一个&lt;code&gt;FunctionalInterface&lt;/code&gt;接口，其源码如下： ```java/** * Strategy interface used to resolve replacement values for placeholders contained in Strings. */@FunctionalInterfacepublic interface PlaceholderResolver &#123; /** * Resolve the supplied placeholder name to the replacement value. * @param placeholderName the name of the placeholder to resolve * @return the replacement value, or &#123;@code null&#125; if no replacement is to be made */ @Nullable String resolvePlaceholder(String placeholderName);&#125;``` ## 问题：FunctionalInterface注解作用如这个注解的名字所示，这个接口只是向大家声明该接口是一个函数接口。而声明为函数接口，有如下要求：- 只能有一个抽象函数(但是有例外，详情见下)。- 可以有default修饰的方法，因为default修饰的方法是已经实现了的- 函数接口中抽象函数可以有多个，但是除了自定义的抽象函数之外的抽象函数必须是Object中已实现的方法。（如：下面的代码） ```java@FunctionalInterfacepublic interface PlaceholderResolver &#123; String resolvePlaceholder(String placeholderName); default void print() &#123; System.out.println("hh "); &#125; public String toString(); public boolean equals(Object obj);&#125;``` 如果不是Object中已经实现的方法，则会报错。如下图：![image](https://user-images.githubusercontent.com/33340562/64415173-626eab00-d0c7-11e9-99a4-c8344c257eb9.png)知道函数接口的定义后，那函数接口怎么使用呢？以及他的作用## 使用步骤 定义一个函数接口```java@FunctionalInterfacepublic interface PlaceholderResolver &#123; String resolvePlaceholder();&#125;``` 定义一个将函数接口作为参数的方法```javapublic void test(PlaceholderResolver placeholderResolver) &#123; placeholderResolver.resolvePlaceholder();&#125;``` 在定义一个方法 ```javapublic String print() &#123; System.out.println("我是print方法") return str;&#125; 现在就可以愉快的使用了123public void test() &#123; test(this::print);&#125; 而上面调用test方法后就会输出在执行placeholderResolver.resolvePlaceholder(“啦啦啦”);时输出我是print方法。其作用也就是将print方法赋给PlaceholderResolver中的resolvePlaceholder，所以在调用resolvePlaceholder方法会执行print。 最后究其到底函数接口只是一个语法糖，它是java8一个新的语法糖。它的效果等价于： public void test() { test(new PlaceholderResolver() { public String resolvePlaceholder() { print(); } }) } 所以在调用resolvePPlaceholder方法时会调用print方法。这样使用函数接口替代匿名内部类，可以是代码更加简洁。但要注意的是print方法要和resolvePlaceholder方法的参数列表、返回参数一致，方法名可以不一致。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant风格]]></title>
    <url>%2F2019%2F09%2F01%2FAnt%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言在阅读dalao的文章时，看到支持Ant风格。遂对Ant风格产生了好奇。遂写此blog以做笔记。 Ant风格：就是匹配路径和url的一种规则。例如：我们常见的C:/project/*.html匹配C盘目录下project文件夹中的所有html文件。 规则 符号 说明 ? 匹配任何单字符 * 匹配0或者任意数量的字符 ** 匹配0或者更多的目录 例如URL路径 | 说明–|–:/project/.a|匹配项目根路径下所有在project路径下的.a文件/project/p?ttern|匹配项目根路径下 /project/pattern 和 /app/pXttern,但是不包括/app/pttern//example|匹配项目根路径下 /project/example, /project/foow/example, 和 /example/project//dir/file.|匹配项目根路径下/project/dir/file.jsp, /project/foow/dir/file.html,/project/foow/bar/dir/file.pdf/*/.jsp|匹配项目根路径下任何的.jsp 文件 注意：如果一个路径存在多个匹配，那么将选择最长的匹配。例如：URL请求/project/dir/file.jsp，现在存在两个路径匹配模式/*/.jsp和/project/dir/.jsp，那么会根据模式/project/dir/.jsp来匹配]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[schemaLocation值必须具有偶数个URI]]></title>
    <url>%2F2019%2F09%2F01%2FschemaLocation%E5%80%BC%E5%BF%85%E9%A1%BB%E5%85%B7%E6%9C%89%E5%81%B6%E6%95%B0%E4%B8%AAURI%2F</url>
    <content type="text"><![CDATA[前言学习并使用spring框架开发已经有了一段很长的时间了，但是之前没有把在学习过程中遇见关于spring的错误积累下来。所以从现在开始，将在此开辟一博客收集我遇见的奇葩错误。 错误一 SchemaLocation: schemaLocation 值必须具有偶数个 URI 该错误是我在学习ignoreDependencyInterface和ignoreDependencyType之间的区别及使用的时候发现的。 我在配置spring的beans.xml时，设置context:annotation-config&lt;/context:annotation-config&gt;。发现要在beans标签中加入xmlns:context=”http://www.springframework.org/schema/context&quot;。（因为我们要用到context标签所以要引入context） 加入后运行。 代码提示报错 12345678910111213141516Exception in thread "main" org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 52 in XML document from file [C:\Users\Administrator\Downloads\adaptive-loadbalance-master-154377df0a8f753f2ea462ec15a6f76f882691bc\study\src\main\resources\META-INF\spring\camel-context.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 52; columnNumber: 30; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 'context:annotation-config' 的声明。 at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:404) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:336) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:195) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:257) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:128) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:94) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:133) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:636) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:521) at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:142) at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:85) at study.Application.main(Application.java:11) 原因是因为在12xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd" 中要加入12http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 刚开始年轻的我只加入了一个1http://www.springframework.org/schema/context 导致报错1org.xml.sax.SAXParseException: SchemaLocation: schemaLocation 值 'http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd http://www.springframework.org/schema/context' 必须具有偶数个 URI。 总结通过这次错误，我们可以知道要在beans.xml中加入一个标签的流程如下（以context为例）： 第一步：加入1xmlns:context="http://www.springframework.org/schema/context" 第二步：在xsi:schemaLocation中加入1http://www.springframework.org/schema/context 第三步：在xsi:schemaLocation中加入1http://www.springframework.org/schema/spring-context.xsd]]></content>
      <categories>
        <category>错误</category>
      </categories>
      <tags>
        <tag>spring错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuffer神秘的toStringCache属性]]></title>
    <url>%2F2019%2F08%2F17%2FStringBuffer%E7%A5%9E%E7%A7%98%E7%9A%84toStringCache%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言 大家都知道直接对String字符串进行拼接等操作时，会创建大量的String对象。因此用String直接进行这些操作效率会很低。所以催生了StringBuilder和StringBuffer这两个类。这两个类基本相同，但是StringBuffer多了一个toStringCache变量（后面具体讲解该变量作用），并在方法体上加了synchronized。 StringBuilder和StringBuffer的相同点 都继承于AbstractStringBuilder类。 都实现了java.io.Serializable, CharSequence接口。 字符串都是存储在一个字符数组中。StringBuilder和StringBuffer不同点一 StringBuffer是线程安全的，而StringBuilder是线程不安全的。那StringBuffer是怎么实现线程安全的呢？通过源码的对比，可以看到两个类的实现大致相同，不一样的就是StringBuffer在方法体加了synchronized。 StringBuilder和StringBuffer不同点二 在对比两个类的源码，发现StringBuffer多了一个toStringCache12345/** * A cache of the last value returned by toString. Cleared * whenever the StringBuffer is modified. */ private transient char[] toStringCache; 这个属性的作用是缓存toString方法返回的最后一个值，当StringBuffer对象被修改时，这个变量都会被设置为NULL。 toStringCache的作用 众所周知对字符串的操作效率StringBuilder &gt; StringBuffer &gt; String也就是说StringBuffer的效率并不是最棒的，所以仍需提高，设置toStringCache的作用就是为了提高效率 问题来了：toStringCache是怎么提高效率的 先看看StringBuilder和StringBuffer两个类中的toString方法 StringBuffer的toString方法1234567@Overridepublic synchronized String toString() &#123; if (toStringCache == null) &#123; toStringCache = Arrays.copyOfRange(value, 0, count); &#125; return new String(toStringCache, true);&#125; StringBuilder的toString方法12345@Overridepublic String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count);&#125; 从两个方法中可以看到StringBuffer已经将方法重写为了synchronized方法，已经实现了线程安全，可是方法的具体实现却不同。 两个方法创建String的方法分别为： new String(toStringCache, true); –对应的构造方法–&gt; String(char[] value, boolean share)new String(value, 0, count); –&gt;对应的构造方法–&gt; String(char value[], int offset, int count) 所以现在需要去了解两个构造方法的不同 12345678910111213public String(char value[], int offset, int count) &#123; //此处省略一部分代码 ...... this.value = Arrays.copyOfRange(value, offset, offset+count); //复制数组到value &#125;&#125;//完整的函数，就是这么简单粗暴String(char[] value, boolean share) &#123; // assert share : "unshared not supported"; this.value = value;&#125; 从上面可以看出调用String(char[] value, boolean share) 不用复制数组调用String(char value[], int offset, int count) 需要复制数组 再回到StringBuffer和StringBuilder的toString方法就知道StringBuffer只有当toStringCache是NULL的时候（也就是当字符串发生变化）需要复制数组，而StringBuilder的toString方法每次创建String都要复制数组。所以现在清楚了toStringCache就是这样提高一点点效率。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的生命周期]]></title>
    <url>%2F2019%2F07%2F22%2FSpring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[我们都知道Spring的IOC容器帮我们管理着Bean，我们可以从IOC容器中拿到我们想要的Bean对象。但是IOC是如何管理我们的Bean呢？下面将会从源码分析的角度来介绍Spring中Bean的生命周期。 BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解) 12345678910111213141516171819202122232425/** * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is:&lt;br&gt; * 1. BeanNameAware's &#123;@code setBeanName&#125;&lt;br&gt; * 2. BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;&lt;br&gt; * 3. BeanFactoryAware's &#123;@code setBeanFactory&#125;&lt;br&gt; * 4. ResourceLoaderAware's &#123;@code setResourceLoader&#125; * (only applicable when running in an application context)&lt;br&gt; * 5. ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125; * (only applicable when running in an application context)&lt;br&gt; * 6. MessageSourceAware's &#123;@code setMessageSource&#125; * (only applicable when running in an application context)&lt;br&gt; * 7. ApplicationContextAware's &#123;@code setApplicationContext&#125; * (only applicable when running in an application context)&lt;br&gt; * 8. ServletContextAware's &#123;@code setServletContext&#125; * (only applicable when running in a web application context)&lt;br&gt; * 9. &#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors&lt;br&gt; * 10. InitializingBean's &#123;@code afterPropertiesSet&#125;&lt;br&gt; * 11. a custom init-method definition&lt;br&gt; * 12. &#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors * * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;br&gt; * 1. DisposableBean's &#123;@code destroy&#125;&lt;br&gt; * 2. a custom destroy-method definition **/ 注释翻译（翻译错的请轻喷）Bean工厂的实现者应该尽可能支持标准的Bean生命周期接口。Bean的初始化方法和他们标准的执行顺序如下：1.BeanNameAware的setBeanName方法2.BeanClassLoaderAware的setBeanClassLoader方法3.BeanFactoryAware的setBeanFactory方法4.ResourceLoaderAware的setResourceLoader方法5.ApplicationEventPublisherAware的setApplicationEventPublisher方法6.MessageSourceAware的setMessageSource方法7.ApplicationContextAware的setApplicationContext方法8.ServletContextAware的setServletContext方法9.BeanPostProcessors的postProcessAfterInitialization方法初始化完毕 -&gt; 进行我们的业务操作Bean的关闭生命周期调用方法1.DisposableBean的destroy方法2.在配置文件中指定的destroy-method方法 看完这个注释后，我们将回到源码找到Bean执行以上方法的地方。通过调试我们可以找到执行上述步骤的方法为initializeBean方法。123456789101112131415161718192021222324252627282930protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 上面的代码就为该方法，我将该方法分为四部分。 第一部分执行所有的Aware方法也就是上面提到的invokeAwareMethods方法该方法将XXXAware对应的XXX对象传给bean。例如BeanNameAware就会将beanName传给bean。12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 第二部分执行Bean后置处理器的postProcessBeforeInitialization方法Bean后置处理器也就是BeanPostProcessor的实现类。也就是initializeBean方法中applyBeanPostProcessorsBeforeInitialization调用。在applyBeanPostProcessorsBeforeInitialization方法中，Spring将遍历执行系统自带的和用户定义的所有Bean后置处理器。12345678910public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 第三部分执行Bean的Init方法在这里首先会判断Bean是否继承了InitializingBean接口如果继承了InitializingBean接口，就调用InitializingBean接口的afterPropertiesSet方法。然后判断用户在配置Bean的时候是否指定了init方法（xml配置为指定init-method，注解配置为PostConstruct）。如果指定了就调用。123456789101112131415161718192021222324252627282930313233protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'"); &#125; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; if (mbd != null) &#123; String initMethodName = mbd.getInitMethodName(); if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; "afterPropertiesSet".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125;&#125; 第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步 到此Bean的初始化就完成了。后面就是Bean的销毁销毁跟初始化调用Bean的init方法一样，不过在销毁的时候是判断Bean是否实现了DisposableBean接口，如果实现了就调用DisposableBean的destroy方法。然后在判断Bean是否指定了销毁方法（xml方式是destroy-method，注解方式是@PreDestroy） 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void destroy() &#123; if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123; for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123; processor.postProcessBeforeDestruction(this.bean, this.beanName); &#125; &#125; if (this.invokeDisposableBean) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking destroy() on bean with name '" + this.beanName + "'"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((DisposableBean) bean).destroy(); return null; &#125; &#125;, acc); &#125; else &#123; ((DisposableBean) bean).destroy(); &#125; &#125; catch (Throwable ex) &#123; String msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'"; if (logger.isDebugEnabled()) &#123; logger.warn(msg, ex); &#125; else &#123; logger.warn(msg + ": " + ex); &#125; &#125; &#125; if (this.destroyMethod != null) &#123; invokeCustomDestroyMethod(this.destroyMethod); &#125; else if (this.destroyMethodName != null) &#123; Method methodToCall = determineDestroyMethod(); if (methodToCall != null) &#123; invokeCustomDestroyMethod(methodToCall); &#125; &#125;&#125; Bean的生命周期总结 调用XXXAware方法的setXXX–&gt;调用Bean后置处理器的postProcessBeforeInitialization–&gt;调用InitializingBean接口的afterPropertiesSet方法–&gt;调用用户指定的初始方法–&gt; 业务 –&gt;调用DisposableBean接口的destory方法–&gt;调用用户指定的销毁方法]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory、FactoryBean、ObjectFactory的区别]]></title>
    <url>%2F2019%2F07%2F21%2FBeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[这三个类都属于org.springframework.beans.factory包下，并且名字都有点相似，但在功能上却大部相同。具体有哪些不同呢？下面将从这三个类的功能与用法分别分析。 BeanFactory 该类名以Factory结尾，其实质为一个Bean工厂接口，源码如下。从源码可以看出这个接口定义了Bean工厂的一些基本操作。所以这个接口起到了规范Bean工厂的基本操作作用。其基本实现有HierarchicalBeanFactory、ListableBeanFactory和ConfigurableBeanFactory以及各种ApplicationContext等等。如果想看BeanFactory的基本实现可以去看ListableBeanFactory的源码。而BeanFactory的使用则推荐使用ApplicationContext的一些派生类（如FileSystemXmlApplicationContext以及AnnotationConfigApplicationContext等类） 1234567891011121314151617public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = "&amp;"; // 这个与FactoryBean有关，后面会介绍到 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; //是否是多例的意思 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); // 获取Bean的别名&#125; FactoryBean 该类以Bean结尾，自然就是一个Bean，但这个Bean不是普通的Bean。这个Bean的设计类似于工厂模》&gt;式，专门用于创建特定的对象。可是Spring控制反转不是把对象的创建控制权交给了BeanFactory进行管理吗？那是因为有些创建比较复杂的类用配置文件来描述初始化不方便（Bean工厂要读取xml或者注解形式的类的初始化相关属性，这样Bean工厂才知道怎么帮我们创建该对象）。源码如下。 123456789public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; getObject方法便是这个FactoryBean创建对象的地方。调用这个方法就可以获取他创建的一个对象。 使用方法（本次只展示xml方式） 展示中涉及三个类Test类：main方法Car类：FactoryBean中构建的。CarFactoryBean类：继承了FactoryBean专用来构建Car的。 Car 123456public class Car &#123; @Override public String toString() &#123; return "I'm Car"; &#125;&#125; CarFactoryBean在getObject方法中构建Car对象。 123456789101112131415161718192021class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; public Car getObject() throws Exception &#123; //FactoryBean专门用来创建初始化复杂的对象 //此处假设在进行很复杂的构造对象 return new Car(); &#125; public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; public boolean isSingleton() &#123; return false; &#125; @Override public String toString() &#123; return "I'm CarFactory"; &#125;&#125; 配置文件beans.xml。 注意此处name为bean对应的是CarFactoryBean,等下注意使用getBean方法获取的对象是什么。 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="bean" class="com.test.CarFactoryBean"/&gt;&lt;/beans&gt; Test 123456789public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); Object obj1 = ctx.getBean("car"); System.out.println(obj1); Object obj2 = ctx.getBean("&amp;car");// 注意这里的区别 System.out.println(obj2); &#125;&#125; 最后输出的结果如下 所以大家发现了没，在配置文件中我们配置的是car对应CarFactoryBean对象的，但是在getBean(“car”)时，取到的却是Car对象。这正是FactoryBean作用之处，在getBean中自动的调用了FactoryBean的getObject方法，并将FactoryBean构建的对象返回。如果想得到的是CarFactoryBean对象呢？那就要在car前面加个&amp;符号(心细的同学可能记得前面BeanFactory源码中也提到了&amp;符号，其作用就是这个）。 通过Debug看源码可以看出在AbstractBeanFactory类中的getObjectForBeanInstance方法 12345678910111213141516171819202122232425262728293031protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123; if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; //判断是否实现了FactoryBean接口， //如果没实现就返回bean对象。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; //如果实现了FactoryBean对象 //则从FactoryBean中调用getObject方法获取对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // Return bean instance from factory. FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; ObjectFactory 跟FactoryBean一样，用工厂模式创建对象。源码如下。那么竟然与FactoryBean类似，都是用于创建对象。那两者有什么区别呢？我们注意到FactoryBean中还具有isSingleton、getObjectType等方法。这些方法是专门用于bean工厂的。从这个接口的注释也可以得出FactoryBean是专为BeanFactory所设计（This interface is similar to {@link FactoryBean}, but implementations of the latter are normally meant to be defined as SPI instances in a {@link BeanFactory}）。因此ObjectFactory只是一个普通的工厂模式中的工厂接口。 1234567891011121314151617181920212223242526/** * Defines a factory which can return an Object instance * (possibly shared or independent) when invoked. * &lt;p&gt;This interface is typically used to encapsulate a generic factory which * returns a new instance (prototype) of some target object on each invocation. * &lt;p&gt;This interface is similar to &#123;@link FactoryBean&#125;, but implementations * of the latter are normally meant to be defined as SPI instances in a * &#123;@link BeanFactory&#125;, while implementations of this class are normally meant * to be fed as an API to other beans (through injection). As such, the * &#123;@code getObject()&#125; method has different exception handling behavior. * * @author Colin Sampaleanu * @since 1.0.2 * @see FactoryBean */public interface ObjectFactory&lt;T&gt; &#123; /** * Return an instance (possibly shared or independent) * of the object managed by this factory. * @return an instance of the bean (should never be &#123;@code null&#125;) * @throws BeansException in case of creation errors */ T getObject() throws BeansException;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F06%2F06%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机常见英语单词翻译]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>大杂烩</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云环境下配置Nginx的SSL证书]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[阿里云服务器Nginx环境下配置SSL证书HTTPS的认识### HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 &#8194;&#8194;一般我们的服务器默认使用http协议，而https协议则需要自己配置协议，所以当在浏览器输入栏输入域名前加https时，会显示无法访问（如图1-1所示)。所以本次我将记录下在阿里云服务器Nginx环境下配置https协议过程。如在其他云运行商，亦可参考。 第一步：下载SSL证书 SSL证书分为收费版和免费的，作为一个土豆丝，我只能申请免费版的ssl证书，为期一年，但是可以无限申请。至于在哪里下呢。请按如下步骤。 进入域名的云解析控制台 （当然，前提是咱们有个域名）界面如图（2-1）所示 在你要配置SSL证书的那一项点击旁边的更多，然后又一个SSL证书按钮（如图2-2），点击它。 申请Symantec DV SSL证书 在阿里云平台中该证书是免费的，但是期限只有一年，一年后过期可再来申请。如图2-3填写要申请的域名，刚开始我输入*想为所有二级域名配置ssl证书，但是发现申请的按钮是灰的。后来发现输入www则没事，输入别的应该也可以吧，大家可以试试。 填写验证信息 大家在这里可能会遇见图2-4这种错误，但是大家不要方。刚开始我也遇见了，后来发现他是在域名解析规则中添加了一个主机记录为_dnsauth的解析规则。而域名解析规则更新到dns服务器上要等一会儿，所以大家乘这个机会喝杯茶，等下点击验证就ojbk。 下载证书 上一步验证成功后，就会跳转到SSL证书下载页面（如图2-5）。大家根据自己的需求下载对应的证书就可以了，我是要配置Nginx的SSL证书所以这里我选择了Nginx版的。到此第一阶段就结束了。 第二步：配置Nginx将证书上传服务器 我先将下载的压缩包解压开，然后里面会有一个pem和key文件。然后通过scp命令（命令如下）将该软件上传到服务器的Nginx配置文件夹中的一个文件夹(SSL文件夹，这个文件夹是我自己建的，大家可以上传到自己喜欢的目录中) 123scp -r 2020586_www.butong.live.key 2020586_www.butong.live.pem root@www.butong.live:/etc/nginx/ssl//格式scp -r 文件[ 文件] 用户名@域名或ip:/上传到的文件夹 修改nginx.conf文件 在server中添加以下几行代码（以下代码可与原来的配置http代码共存，所以无需删除之前http的配置）然后保存退出运行 nginx -s reload命令重启Nginx即可。 12345678910server &#123; listen 443 ssl; ssl on; ssl_certificate ssl/2020586_www.butong.live.pem; # 你解压开的文件放在的目录 ssl_certificate_key ssl/2020586_www.butong.live.key; # 你解压开的文件放在的目录 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; 、、、 # 后面的保持原来的配置文件不变即可 以上就是在阿里云环境下配置Nginx的ssl证书的完整过程。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>HTTPS协议</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error 与 exception的区别]]></title>
    <url>%2F2019%2F02%2F24%2Ferror-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Error与Exception的区别 同 1:两者都继承自Throwable 不同Exception 1: 可以是可被控制或不可控制(例如RuntimeException异常及其子类); 注:可控不可控就看在代码编写时能否检测到异常;2: 表示有一个程序员导致的错误;3: 应该在应用级被处理; Error 1: 总是不可控的（即在编译期不可探测到异常;2: 常用来表示系统错误;3: 应该在系统级被捕获;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
