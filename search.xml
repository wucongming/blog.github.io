<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring中Bean的生命周期]]></title>
    <url>%2F2019%2F07%2F22%2FSpring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[我们都知道Spring的IOC容器帮我们管理着Bean，我们可以从IOC容器中拿到我们想要的Bean对象。但是IOC是如何管理我们的Bean呢？下面将会从源码分析的角度来介绍Spring中Bean的生命周期。 BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解) 12345678910111213141516171819202122232425/** * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is:&lt;br&gt; * 1. BeanNameAware's &#123;@code setBeanName&#125;&lt;br&gt; * 2. BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;&lt;br&gt; * 3. BeanFactoryAware's &#123;@code setBeanFactory&#125;&lt;br&gt; * 4. ResourceLoaderAware's &#123;@code setResourceLoader&#125; * (only applicable when running in an application context)&lt;br&gt; * 5. ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125; * (only applicable when running in an application context)&lt;br&gt; * 6. MessageSourceAware's &#123;@code setMessageSource&#125; * (only applicable when running in an application context)&lt;br&gt; * 7. ApplicationContextAware's &#123;@code setApplicationContext&#125; * (only applicable when running in an application context)&lt;br&gt; * 8. ServletContextAware's &#123;@code setServletContext&#125; * (only applicable when running in a web application context)&lt;br&gt; * 9. &#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors&lt;br&gt; * 10. InitializingBean's &#123;@code afterPropertiesSet&#125;&lt;br&gt; * 11. a custom init-method definition&lt;br&gt; * 12. &#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors * * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;br&gt; * 1. DisposableBean's &#123;@code destroy&#125;&lt;br&gt; * 2. a custom destroy-method definition **/ 注释翻译（翻译错的请轻喷）Bean工厂的实现者应该尽可能支持标准的Bean生命周期接口。Bean的初始化方法和他们标准的执行顺序如下：1.BeanNameAware的setBeanName方法2.BeanClassLoaderAware的setBeanClassLoader方法3.BeanFactoryAware的setBeanFactory方法4.ResourceLoaderAware的setResourceLoader方法5.ApplicationEventPublisherAware的setApplicationEventPublisher方法6.MessageSourceAware的setMessageSource方法7.ApplicationContextAware的setApplicationContext方法8.ServletContextAware的setServletContext方法9.BeanPostProcessors的postProcessAfterInitialization方法初始化完毕 -&gt; 进行我们的业务操作Bean的关闭生命周期调用方法1.DisposableBean的destroy方法2.在配置文件中指定的destroy-method方法 看完这个注释后，我们将回到源码找到Bean执行以上方法的地方。通过调试我们可以找到执行上述步骤的方法为initializeBean方法。123456789101112131415161718192021222324252627282930protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 上面的代码就为该方法，我将该方法分为四部分。 第一部分执行所有的Aware方法也就是上面提到的invokeAwareMethods方法该方法将XXXAware对应的XXX对象传给bean。例如BeanNameAware就会将beanName传给bean。12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 第二部分执行Bean后置处理器的postProcessBeforeInitialization方法Bean后置处理器也就是BeanPostProcessor的实现类。也就是initializeBean方法中applyBeanPostProcessorsBeforeInitialization调用。在applyBeanPostProcessorsBeforeInitialization方法中，Spring将遍历执行系统自带的和用户定义的所有Bean后置处理器。12345678910public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 第三部分执行Bean的Init方法在这里首先会判断Bean是否继承了InitializingBean接口如果继承了InitializingBean接口，就调用InitializingBean接口的afterPropertiesSet方法。然后判断用户在配置Bean的时候是否指定了init方法（xml配置为指定init-method，注解配置为PostConstruct）。如果指定了就调用。123456789101112131415161718192021222324252627282930313233protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'"); &#125; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; if (mbd != null) &#123; String initMethodName = mbd.getInitMethodName(); if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; "afterPropertiesSet".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125;&#125; 第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步 到此Bean的初始化就完成了。后面就是Bean的销毁销毁跟初始化调用Bean的init方法一样，不过在销毁的时候是判断Bean是否实现了DisposableBean接口，如果实现了就调用DisposableBean的destroy方法。然后在判断Bean是否指定了销毁方法（xml方式是destroy-method，注解方式是@PreDestroy） 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void destroy() &#123; if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123; for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123; processor.postProcessBeforeDestruction(this.bean, this.beanName); &#125; &#125; if (this.invokeDisposableBean) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking destroy() on bean with name '" + this.beanName + "'"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((DisposableBean) bean).destroy(); return null; &#125; &#125;, acc); &#125; else &#123; ((DisposableBean) bean).destroy(); &#125; &#125; catch (Throwable ex) &#123; String msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'"; if (logger.isDebugEnabled()) &#123; logger.warn(msg, ex); &#125; else &#123; logger.warn(msg + ": " + ex); &#125; &#125; &#125; if (this.destroyMethod != null) &#123; invokeCustomDestroyMethod(this.destroyMethod); &#125; else if (this.destroyMethodName != null) &#123; Method methodToCall = determineDestroyMethod(); if (methodToCall != null) &#123; invokeCustomDestroyMethod(methodToCall); &#125; &#125;&#125; Bean的生命周期总结 调用XXXAware方法的setXXX–&gt;调用Bean后置处理器的postProcessBeforeInitialization–&gt;调用InitializingBean接口的afterPropertiesSet方法–&gt;调用用户指定的初始方法–&gt; 业务 –&gt;调用DisposableBean接口的destory方法–&gt;调用用户指定的销毁方法]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory、FactoryBean、ObjectFactory的区别]]></title>
    <url>%2F2019%2F07%2F21%2FBeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[这三个类都属于org.springframework.beans.factory包下，并且名字都有点相似，但在功能上却大部相同。具体有哪些不同呢？下面将从这三个类的功能与用法分别分析。 BeanFactory 该类名以Factory结尾，其实质为一个Bean工厂接口，源码如下。从源码可以看出这个接口定义了Bean工厂的一些基本操作。所以这个接口起到了规范Bean工厂的基本操作作用。其基本实现有HierarchicalBeanFactory、ListableBeanFactory和ConfigurableBeanFactory以及各种ApplicationContext等等。如果想看BeanFactory的基本实现可以去看ListableBeanFactory的源码。而BeanFactory的使用则推荐使用ApplicationContext的一些派生类（如FileSystemXmlApplicationContext以及AnnotationConfigApplicationContext等类） 1234567891011121314151617public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = "&amp;"; // 这个与FactoryBean有关，后面会介绍到 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; //是否是多例的意思 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); // 获取Bean的别名&#125; FactoryBean 该类以Bean结尾，自然就是一个Bean，但这个Bean不是普通的Bean。这个Bean的设计类似于工厂模》&gt;式，专门用于创建特定的对象。可是Spring控制反转不是把对象的创建控制权交给了BeanFactory进行管理吗？那是因为有些创建比较复杂的类用配置文件来描述初始化不方便（Bean工厂要读取xml或者注解形式的类的初始化相关属性，这样Bean工厂才知道怎么帮我们创建该对象）。源码如下。 123456789public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; getObject方法便是这个FactoryBean创建对象的地方。调用这个方法就可以获取他创建的一个对象。 使用方法（本次只展示xml方式） 展示中涉及三个类Test类：main方法Car类：FactoryBean中构建的。CarFactoryBean类：继承了FactoryBean专用来构建Car的。 Car 123456public class Car &#123; @Override public String toString() &#123; return "I'm Car"; &#125;&#125; CarFactoryBean在getObject方法中构建Car对象。 123456789101112131415161718192021class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; public Car getObject() throws Exception &#123; //FactoryBean专门用来创建初始化复杂的对象 //此处假设在进行很复杂的构造对象 return new Car(); &#125; public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; public boolean isSingleton() &#123; return false; &#125; @Override public String toString() &#123; return "I'm CarFactory"; &#125;&#125; 配置文件beans.xml。 注意此处name为bean对应的是CarFactoryBean,等下注意使用getBean方法获取的对象是什么。 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="bean" class="com.test.CarFactoryBean"/&gt;&lt;/beans&gt; Test 123456789public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); Object obj1 = ctx.getBean("car"); System.out.println(obj1); Object obj2 = ctx.getBean("&amp;car");// 注意这里的区别 System.out.println(obj2); &#125;&#125; 最后输出的结果如下 所以大家发现了没，在配置文件中我们配置的是car对应CarFactoryBean对象的，但是在getBean(“car”)时，取到的却是Car对象。这正是FactoryBean作用之处，在getBean中自动的调用了FactoryBean的getObject方法，并将FactoryBean构建的对象返回。如果想得到的是CarFactoryBean对象呢？那就要在car前面加个&amp;符号(心细的同学可能记得前面BeanFactory源码中也提到了&amp;符号，其作用就是这个）。 通过Debug看源码可以看出在AbstractBeanFactory类中的getObjectForBeanInstance方法 12345678910111213141516171819202122232425262728293031protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123; if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; //判断是否实现了FactoryBean接口， //如果没实现就返回bean对象。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; //如果实现了FactoryBean对象 //则从FactoryBean中调用getObject方法获取对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // Return bean instance from factory. FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; ObjectFactory 跟FactoryBean一样，用工厂模式创建对象。源码如下。那么竟然与FactoryBean类似，都是用于创建对象。那两者有什么区别呢？我们注意到FactoryBean中还具有isSingleton、getObjectType等方法。这些方法是专门用于bean工厂的。从这个接口的注释也可以得出FactoryBean是专为BeanFactory所设计（This interface is similar to {@link FactoryBean}, but implementations of the latter are normally meant to be defined as SPI instances in a {@link BeanFactory}）。因此ObjectFactory只是一个普通的工厂模式中的工厂接口。 1234567891011121314151617181920212223242526/** * Defines a factory which can return an Object instance * (possibly shared or independent) when invoked. * &lt;p&gt;This interface is typically used to encapsulate a generic factory which * returns a new instance (prototype) of some target object on each invocation. * &lt;p&gt;This interface is similar to &#123;@link FactoryBean&#125;, but implementations * of the latter are normally meant to be defined as SPI instances in a * &#123;@link BeanFactory&#125;, while implementations of this class are normally meant * to be fed as an API to other beans (through injection). As such, the * &#123;@code getObject()&#125; method has different exception handling behavior. * * @author Colin Sampaleanu * @since 1.0.2 * @see FactoryBean */public interface ObjectFactory&lt;T&gt; &#123; /** * Return an instance (possibly shared or independent) * of the object managed by this factory. * @return an instance of the bean (should never be &#123;@code null&#125;) * @throws BeansException in case of creation errors */ T getObject() throws BeansException;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jk]]></title>
    <url>%2F2019%2F07%2F20%2Fjk%2F</url>
    <content type="text"></content>
      <categories>
        <category>�㷨</category>
      </categories>
      <tags>
        <tag>�㷨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F06%2F06%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机常见英语单词翻译]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>大杂烩</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究BeanFactory、FactoryBean、ObjectFactory内幕]]></title>
    <url>%2F2019%2F04%2F26%2F1%2F</url>
    <content type="text"><![CDATA[这三个类都属于org.springframework.beans.factory包下，并且名字都有点相似，但在功能上却大部相同。具体有哪些不同呢？下面将从这三个类的功能与用法分别分析。 BeanFactory 该类名以Factory结尾，其实质为一个Bean工厂接口，源码如下。从源码可以看出这个接口定义了Bean工厂的一些基本操作。所以这个接口起到了规范Bean工厂的基本操作作用。其基本实现有HierarchicalBeanFactory、ListableBeanFactory和ConfigurableBeanFactory以及各种ApplicationContext等等。如果想看BeanFactory的基本实现可以去看ListableBeanFactory的源码。而BeanFactory的使用则推荐使用ApplicationContext的一些派生类（如FileSystemXmlApplicationContext以及AnnotationConfigApplicationContext等类） 1234567891011121314151617public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = "&amp;"; // 这个与FactoryBean有关，后面会介绍到 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; //是否是多例的意思 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); // 获取Bean的别名&#125; FactoryBean 该类以Bean结尾，自然就是一个Bean，但这个Bean不是普通的Bean。这个Bean的设计类似于工厂模式，专门用于创建特定的对象。可是Spring控制反转不是把对象的创建控制权交给了BeanFactory进行管理吗？那是因为有些创建比较复杂的类用配置文件来描述初始化不方便（Bean工厂要读取xml或者注解形式的类的初始化相关属性，这样Bean工厂才知道怎么帮我们创建该对象）。源码如下。123456789public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; getObject方法便是这个FactoryBean创建对象的地方。调用这个方法就可以获取他创建的一个对象。 使用方法（本次只展示xml方式） 展示中涉及三个类Test类：main方法Car类：FactoryBean中构建的。CarFactoryBean类：继承了FactoryBean专用来构建Car的。 Car123456public class Car &#123; @Override public String toString() &#123; return "I'm Car"; &#125;&#125; CarFactoryBean在getObject方法中构建Car对象。123456789101112131415161718192021class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; public Car getObject() throws Exception &#123; //FactoryBean专门用来创建初始化复杂的对象 //此处假设在进行很复杂的构造对象 return new Car(); &#125; public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; public boolean isSingleton() &#123; return false; &#125; @Override public String toString() &#123; return "I'm CarFactory"; &#125;&#125; 配置文件beans.xml。 注意此处name为bean对应的是CarFactoryBean,等下注意使用getBean方法获取的对象是什么。12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="bean" class="com.test.CarFactoryBean"/&gt;&lt;/beans&gt; Test 123456789public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); Object obj1 = ctx.getBean("car"); System.out.println(obj1); Object obj2 = ctx.getBean("&amp;car");// 注意这里的区别 System.out.println(obj2); &#125;&#125; 最后输出的结果如下 所以大家发现了没，在配置文件中我们配置的是car对应CarFactoryBean对象的，但是在getBean(“car”)时，取到的却是Car对象。这正是FactoryBean作用之处，在getBean中自动的调用了FactoryBean的getObject方法，并将FactoryBean构建的对象返回。如果想得到的是CarFactoryBean对象呢？那就要在car前面加个&amp;符号(心细的同学可能记得前面BeanFactory源码中也提到了&amp;符号，其作用就是这个）。 通过Debug看源码可以看出在AbstractBeanFactory类中的getObjectForBeanInstance方法 12345678910111213141516171819202122232425262728293031protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123; if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; //判断是否实现了FactoryBean接口， //如果没实现就返回bean对象。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; //如果实现了FactoryBean对象 //则从FactoryBean中调用getObject方法获取对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // Return bean instance from factory. FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; ObjectFactory 跟FactoryBean一样，用工厂模式创建对象。源码如下。那么竟然与FactoryBean类似，都是用于创建对象。那两者有什么区别呢？我们注意到FactoryBean中还具有isSingleton、getObjectType等方法。这些方法是专门用于bean工厂的。从这个接口的注释也可以得出FactoryBean是专为BeanFactory所设计（This interface is similar to {@link FactoryBean}, but implementations of the latter are normally meant to be defined as SPI instances in a {@link BeanFactory}）。因此ObjectFactory只是一个普通的工厂模式中的工厂接口。1234567891011121314151617181920212223242526/** * Defines a factory which can return an Object instance * (possibly shared or independent) when invoked. * &lt;p&gt;This interface is typically used to encapsulate a generic factory which * returns a new instance (prototype) of some target object on each invocation. * &lt;p&gt;This interface is similar to &#123;@link FactoryBean&#125;, but implementations * of the latter are normally meant to be defined as SPI instances in a * &#123;@link BeanFactory&#125;, while implementations of this class are normally meant * to be fed as an API to other beans (through injection). As such, the * &#123;@code getObject()&#125; method has different exception handling behavior. * * @author Colin Sampaleanu * @since 1.0.2 * @see FactoryBean */public interface ObjectFactory&lt;T&gt; &#123; /** * Return an instance (possibly shared or independent) * of the object managed by this factory. * @return an instance of the bean (should never be &#123;@code null&#125;) * @throws BeansException in case of creation errors */ T getObject() throws BeansException;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云环境下配置Nginx的SSL证书]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[阿里云服务器Nginx环境下配置SSL证书HTTPS的认识### HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 &#8194;&#8194;一般我们的服务器默认使用http协议，而https协议则需要自己配置协议，所以当在浏览器输入栏输入域名前加https时，会显示无法访问（如图1-1所示)。所以本次我将记录下在阿里云服务器Nginx环境下配置https协议过程。如在其他云运行商，亦可参考。 第一步：下载SSL证书 SSL证书分为收费版和免费的，作为一个土豆丝，我只能申请免费版的ssl证书，为期一年，但是可以无限申请。至于在哪里下呢。请按如下步骤。 进入域名的云解析控制台 （当然，前提是咱们有个域名）界面如图（2-1）所示 在你要配置SSL证书的那一项点击旁边的更多，然后又一个SSL证书按钮（如图2-2），点击它。 申请Symantec DV SSL证书 在阿里云平台中该证书是免费的，但是期限只有一年，一年后过期可再来申请。如图2-3填写要申请的域名，刚开始我输入*想为所有二级域名配置ssl证书，但是发现申请的按钮是灰的。后来发现输入www则没事，输入别的应该也可以吧，大家可以试试。 填写验证信息 大家在这里可能会遇见图2-4这种错误，但是大家不要方。刚开始我也遇见了，后来发现他是在域名解析规则中添加了一个主机记录为_dnsauth的解析规则。而域名解析规则更新到dns服务器上要等一会儿，所以大家乘这个机会喝杯茶，等下点击验证就ojbk。 下载证书 上一步验证成功后，就会跳转到SSL证书下载页面（如图2-5）。大家根据自己的需求下载对应的证书就可以了，我是要配置Nginx的SSL证书所以这里我选择了Nginx版的。到此第一阶段就结束了。 第二步：配置Nginx将证书上传服务器 我先将下载的压缩包解压开，然后里面会有一个pem和key文件。然后通过scp命令（命令如下）将该软件上传到服务器的Nginx配置文件夹中的一个文件夹(SSL文件夹，这个文件夹是我自己建的，大家可以上传到自己喜欢的目录中) 123scp -r 2020586_www.butong.live.key 2020586_www.butong.live.pem root@www.butong.live:/etc/nginx/ssl//格式scp -r 文件[ 文件] 用户名@域名或ip:/上传到的文件夹 修改nginx.conf文件 在server中添加以下几行代码（以下代码可与原来的配置http代码共存，所以无需删除之前http的配置）然后保存退出运行 nginx -s reload命令重启Nginx即可。 12345678910server &#123; listen 443 ssl; ssl on; ssl_certificate ssl/2020586_www.butong.live.pem; # 你解压开的文件放在的目录 ssl_certificate_key ssl/2020586_www.butong.live.key; # 你解压开的文件放在的目录 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; 、、、 # 后面的保持原来的配置文件不变即可 以上就是在阿里云环境下配置Nginx的ssl证书的完整过程。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>HTTPS协议</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error 与 exception的区别]]></title>
    <url>%2F2019%2F02%2F24%2Ferror-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Error与Exception的区别 同 1:两者都继承自Throwable 不同Exception 1: 可以是可被控制或不可控制(例如RuntimeException异常及其子类); 注:可控不可控就看在代码编写时能否检测到异常;2: 表示有一个程序员导致的错误;3: 应该在应用级被处理; Error 1: 总是不可控的（即在编译期不可探测到异常;2: 常用来表示系统错误;3: 应该在系统级被捕获;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
