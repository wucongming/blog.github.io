<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android知识汇总“ hexo new Android知识汇总”]]></title>
    <url>%2F2019%2F11%2F19%2FAndroid%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[第一章JDK全称：Java Development Toolkit（Java语言开发工具包）。其中包含java虚拟机、java工具以及一些java基础类库。 Android SDK全程：Android Software Developmen Kit（安卓软件开发工具箱）。其提供了在windows/linux/mac平台开发安卓应用的开发组件，包含了在Android平台开发移动应用的各种工具集（例如：调试、打包等工具） HAXMintel的硬件加速执行管理器，利用intel的虚拟化技术加速Android开发的硬件辅助虚拟引擎。 Gradle是一个项目构建工具，支持自动下载依赖包以及打包项目 第二章项目结构目录 文件 用户 .gradle Gradle编译系统 .idea Android Studio IDE配置文件 app 应用源码核心文件夹 build 代码编译后生成的文件存放目录 gradle wrapper的jar和配置文件在的地方 .gitinore git的ignore配置文件 build.gradle gradle编译的相关配置文件 gradle.propperties gradle相关的全局属性配置 gradlew gradle wrapper的可执行文件 gradlew.bat windows下gradle wrapper的可执行文件 Hello World.iml 项目的配置文件 local.properties 本地属性配置（key设置，Android sdk位置等属性 settings.gradle gradle的设置脚本 External.Librari 引用库 辅助工具 名称 功能 aapt 产生R文件，以使资源文件能够在代码中引用 Navigation Editor 可视化管理Android 应用的结构和布局文件 adb 查询设备信息和数据库，安装程序到设备，端口映射以及移动文件等管理操作 Android 工具 创建和管理android virtual devices Android层级阅览器 显示出各组件的布局及其联系 Draw Nine-patch 让开发设计能够拉伸的png图 DDMS（Dalvik Debug Monitor Service） 查看和管理运行在设备上的进程和线程、查看堆栈数据、连接到进程进行调试 Sqlite3 Android内置数据库 TraceView 将安卓程序产生的日志转化为图形化的分析师图 logcat 日志输出工具 第三章体系结构Linux内核（主要是一些驱动） —&gt; 系统运行库（媒体库、webkit、ssl等） —&gt; 应用程序框架（活动管理器、电话管理器、资源管理器等） —&gt; 应用程序（联系人、电话、浏览器等） 应用程序编译原理和运行原理 首先将资源编译为.java -&gt; 将.java编译为平台无关的.class -&gt; 将散乱的.class集合为虚拟机可加载可运行的.dex文件 -&gt; 将.dex与资源打包为未签名的apk -&gt; 将未签名的apk签名 -&gt; 将签名的apk优化 使用aapt工具将Application Resource编译为R.java和Compiled Resource。 使用aidl工具将.aidl文件编译为.java文件 使用javac将.java文件编译为.class文件 使用dx.bat文件将所有.class文件和第三方库集合成DVM可加载的.dex文件 apkbuilder将Compiled Resource、.dex以及其它的Resource打包成apk 使用jarsigned将打包的apk签名（签名需要Debug Keystore or Release Keystore)形成signed APK 使用zipalign优化打包的apk activity四种加载模式 standard （默认） singleTop singleTask singleInstance 下面我们用ABCDB的activity调用顺序模拟活动启动顺序 standard模式 最终：栈中有5个activity实例解释：standard每次startActivity都会创建一个新的activity实例 singleTop模式 example 1 example 2input: abcdd 最终：栈中有4个activity实例解释：singleTop当当前栈顶的activity是我们要启动的新activity时，直接使用栈顶的activity（调用其onNewIntent()），不会创建新的activity。 singleTask模式 最终：栈中有2个activity实例解释：singleTask模式，如果栈中存在要启动的activity时，直接将该activity上的activity弹出，直到该activity位于栈顶。如果栈中不存在，则创建新的activity。 singleInstance模式 示例解释FirstActivity、ThirdActivity是standard模式，SecondActivity是singleInstance模式首先启动FirstActivity然后启动secondActivity，再启动ThirdActivity。然后按返回键 最终：启动ThirdActivity后，总共有三个activity实例，两个任务栈。解释：singleInstance模式时，会新建一个栈存放该activity。并且该栈只能存放该activity。所以在启动SecondActivity时，会将该activity放到返回栈B中。在启动ThirdActivity时，由于当前是显示SecondActivity，而栈B只能存放SecondActivity，所以启动ThirdActivity会重新回到栈A中。 service service是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。服务像Activity那样也是默认运行在主线程中，如果有耗时任务还是要在服务内部创建子线程，不然程序会GG。 应用案例： 用于处理网络事务（下载文件） 播放音乐（音乐播放器） 执行IO操作 服务的生命周期 通过startService启动的服务 该服务需要在AndroidManifest.xml中配置 12&lt;service android:name=".MyService" &gt;&lt;/service&gt; 第一次调用startService(Intent)时： 执行onCreate() –&gt; onStartCommand() –&gt; service running 第二次调用startService(Intent)时：执行onStartCommand() –&gt; service running 关闭可以调用activity中的stopService和service中的stopSelf：执行onDestory() –&gt; service shut down onCreate() –&gt; onStartCommand() –&gt; service running –&gt;onDestory() –&gt; service shut down 通过bindService启动的服务 调用bindService时：执行onCreate() –&gt; onBind()(只会执行一次) –&gt; service running unbindService: activity退出时一定要调用unbindService，当所有 onCreate() –&gt; onBind() –&gt; service running –&gt; onUnbind() –&gt; onDestory() –&gt; service shut down BroadCastReceiver分类：常驻型广播、非常驻型广播 非常驻型广播 生命周期由开发者决定，通常在activity的onCreate方法中注册广播接收者，在onDestory中销毁广播。 使用 第一步：定义接收者 123456789public class NReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, "onReceiv", 1).show(); &#125;&#125; 第二步：注册 123456public void reigster() &#123; NReceiver receiver = new NReceiver(); // 定义广播接收的消息 IntentFilter filter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED"); registerReceiver(receiver,filter);&#125; 最后：销毁广播 12345@Overrideprotected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(receiver);&#125; 常驻型广播 常驻型广播即使应用退出，也能接收到广播。 使用 第一步 同上定义实现广播类 第二步：在AndroidManifest中注册 12345678&lt;receiver android:name=".receiver.NReceiver" android:enabled="true" android:exported="true"&gt; &lt;intent-filter &gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"&gt;&lt;/action&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播12Intent i = new Intent("com.hmkcode.android.USER_ACTION");sendBroadcast(i); ContentProvider 实现不同的应用程序之间共享数据 第四章activity activity的四种状态： Active/Runningactivity处于屏幕的最前端，用户可以看到，并且与之交互。 Paused用户依然能看到activity，但是用户不能与之交互。因为一个活动被另一个非全屏的活动覆盖住。例如：Dialog。处于这种状态的activity依然是活的，依然维护其相关信息，系统只会在内存极低的时候才将其回收。 Stop已经完全不能看见该界面，但系统依然维持其相关内部状态。在手机内存被征用时，系统经常会将其回收。 Killedactivity已被系统回收或者还未启动 其他两个回调函数 onSaveInstanceState()Android系统在资源不足而终止activity之前调用，用以保存activity的 状态信息 onRestoreInstanceState()恢复onSaveInstanceState保存的状态信息，在onStart与onResume之间使用。 两个activity跳转时，调用顺序： 系统将先后执行Activity1的onPause()–Activity2的onCreate()–onStart()–onResume()–Activity1的onSaveInstance-State() –onStop()系统在执行完Activity1的onPause()之后，先将Activity2显示出来，再执行Activity1的onStop()操作，在执行完Activity1的onPause()后，Activity1便不显示在屏幕的最前端了。 由Activity1-&gt;Activity2-&gt;Back: 系统先后执行了Activity2的onPause()–Activity1的onRestart()–onStart()–onResume()–Activity2的onStop()–onDestory() fragment出现背景在Android3.0之前版本，app通常是运行在小屏幕的设备上。随后为了支持大屏幕的平板电脑能够显示更多的信息，引进了fragment布局。一个activity中的不同fragment有各自的生命周期，因此能够专心处理各自的业务逻辑，而且共显示在一块屏幕上。 生命周期Fragment是依赖于Activity存在的，所以生命周期与Activiy也有所相似。 activity的onCreate对应Fragment: onAttach() –&gt; onCreate() –&gt; onCreateView() –&gt; onActivityCreated() activity的onDestory()对应Fragment: onDestoryView() –&gt; onDestory() –&gt; onDetach() Intent属性 Intent的Action（动作） Action属性用于描述Intent要完成的动作 Intent的Data（数据） Data属性是执行动作的URI和MIME类型，可以传参 Intent的Category（分类） Category属性指明一个执行Action的分类 Category属性 说明 CATEGORY_DEFAULT 默认的执行方式，按照普通Activity的执行方式执行 CATEGORY_HOME 该组件为Home Activity CATEGORY_LAUNCHER 优先级最高的Activity，通常为入口ACTION_MAIN配合使用 CATEGORY_BROWSABLE 可以使用浏览器启动 CATEGORY_GADGET 可以内嵌到另外的Activity中 Intent的Component（组件） Component属性用于指明Intent目标组件的类名称。通常Android会根据Intent中包含的其他属性的信息，进行查找一个与之匹配的目标组件。但是，如果指定了Component这个属性，Intent则会直接根据组件名查找到相应的组件。 使用时例如：intent.setClass(Activity1.this, Activity2.class)这里就是指明了哪个组件 Intent的Extra Extra属性用于添加一些附加信息 三种跳转方式 不带参的跳转 123Intent intent = new Intent();intent.setClass(Activity1.this, Activity2.class);startActivity(intent); 带参的跳转 123456789101112Intent intent = new Intent();Bundle bundle = new Bundle();bundle.putString("Name", "Kate");intent.putExtras(bundle);intent.setClass(Activity1.this, Activity2.class);startActivity(intent);//获取参数Bundle bundle = this.getIntent().getExtras();String name = bundle.getString("Name"); 带返回值的跳转 1234567891011121314151617// 第一个页面Intent intent = new Intent();intent.setClass(Activity1.this, Activity2.class);this.startActivityForResult(intent, 0); //第二个参数用于识别第二个页面传回来的值protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; //此处接收返回的参数&#125;//第二个页面Intent intent = new Intent();Bundle bundle = new Bundle();bundle.putString("Name", "Kate");intent.putExtras(bundle);intent.setClass(Activity2.this, Activity1.class);setResult(RESULT_OK, intent);finish(); 第五章控件与容器 控件eg: Button、TextView等，继承于View，其不能包含其他View 容器eg: LinearLayout等，继承于ViewGroup，其能包含其他控件以及容器 给控件添加监听事件的四种方式 匿名内部类 123456button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //响应事件 &#125;&#125;) 自定义事件监听类 12345678button.setOnClickListener(new MyListener());private class MyListener implements View.OnClickListener &#123; @Override public void onClick(View v) &#123; //响应事件 &#125;&#125; Activity实现OnClickListener接口 123456789101112131415public class AActivity extends Activity implements View.OnClickListener &#123; button.setOnClickListener(this); public void onClick(View v) &#123; switch(v.getId()) &#123; case R.id.btn: //响应事件 break; default: break; &#125; &#125;&#125; 在布局文件中添加onClick属性 12&lt;Button android:onClick="btnClick" /&gt; 123public void btnClick(View v) &#123; //响应事件&#125; Layout LinearLayout 名称：线性布局特点：组件垂直摆放、水平摆放注意：当设置的方向放满后，再添加控件就在屏幕之外，无法看见 RelativeLayout 名称：相对布局特点：利用控件之间的相对位置关系来布局注意：只能与在兄弟组件和父组件进行相对布局 FrameLayout 名称：帧布局特点：该容器中的控件没有上线左右关系，组件之间层叠放置注意：容器中最后写的控件在容器的最顶层，使用android:bringToFront=”true|false”可将控件提到最顶层 TableLayout 名称：表格布局特点：使用TableRow配合TableLayout，让TableLayout生成多个列 AbsoluteLayout 名称：绝对布局特点：以屏幕左上角坐标为原点（0，0），控件位置以坐标的形式存在确定：屏幕兼容性不好 资源文件夹 目录 资源类型 res/animator 存放property animation的xml文件(属性动画，作用于View的属性) res/anim 存放补间动画或逐帧动画的xml文件(作用与View的视觉，不改变属性值) res/raw 存放直接复制到设备中的任意文件，它们无需编译，添加到你的应用程序编译产生的压缩文件中。要使用这些文件，可以调用Resources.openRawResource(),参数是R.raw.somefilename res/drawable 存放能转化为绘制文件的位图或者定义了绘制资源的XML文件 res/color 存放定义了颜色列表资源的XML文件 res/layout 存放定义了用户界面布局的XML文件 res/menu 存放定义了应用程序菜单资源的XML文件 res/values 存放定义了多种类型资源的XML文件(eg:字符串、数据、颜色、尺寸、样式) res/xml 存放任意的xml文件，使用Resources.getXML()读取 第六章service 的基本介绍，前面介绍过 第七章 发送广播的三种方法 Context.sendBroadcast Context.sendOrderedBroadcast Context.sendStickyBroadcast 区别 sendBroadcast或sendStickyBroadcast发送出去的Intent，对于所有满足条件的BroadcastReceiver都会执行其onReceive方法，但是多个BroadcastReceiver的onReceive的执行顺序无法保证。 sendOrderedBroadcastReceiver发出去的Intent，会根据注册时IntentFilter设计的优先级执行onReceive方法，但是同优先级的BroadcastReceive执行顺序无法保证。 sendStickyBroadcast主要特点是，Intent发送后会一直存在，并在以后注册相的Receiver时，会直接将这个Intent返回给刚注册的Receiver。 发送广播1234String Intent_Action = com.android.BroadcastReceiverDemo;Intent intent = new Intent(Intent_Action);Intent.putExtra("参数"，"参数值")；SendBroadcast(intent)； 接收广播12345678910//onReceive()方法必须5秒内执行完事件public class MyBroadcastReceiver extends BroadcastReceiver &#123; String Itent_Action = com.android.BroadcastReceiverDemo; public void onReceive(Context context, Intent intent) &#123; if(intent.getAction().equals(Intent_Action)) &#123; //相应的处理 &#125; &#125;&#125; 注册广播 代码注册广播 非常驻型广播：广播生命周期由程序决定 123456MyBroadcastReceiver receiver = new MyBroadcastReceiver();//实例化过滤器并设置要过滤的广播IntentFilter intentFilter = new IntentFilter("Intent_Action");//注册广播registerReceiver(receiver，intentFilter); AndroidManifext.xml中注册广播 常驻型广播：程序关闭后，有信息广播过来，程序也会调用。 1234567&lt;receiver android:name = "MyBroadcastReceiver" &gt; &lt;intent-filter&gt; &lt;action android:name = " com.androidbook.MyBroadcastReceiver"/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 广播其他分类 广播又分为有序广播和正常广播 有序广播的优先级范围 -1024 至 1024。数字越大，优先级越大。动态注册的广播优先级总是高于静态注册的广播 第八章安卓的四种数据存储：SharedPreference、SQLite、File和ContentProvider。 SharedPreference：一种常用的数据存储方式，其本质是基于XML文件存储键值对，通常用来存储一些简单的配置信息。 SQLite：一个轻量级数据库，执行SQL语句。 文件存储：常用于存储数据量比较大的文件，缺点是更新数据困难。 ContentProvider：用于安卓系统中应用程序之间数据共享的一种方式。 SharedPreference123456789101112131415SharedPreferences sharedPreferences = getSharedPreferences("type",Context.MODE_APPEND);Editor editor = sharedPreferences.edit();// String字符串型editor.putString("String", "words");// Boolean布尔型editor.putBoolean("Boolean", true);// Integer整型editor.putInt("Integer", 1);// Long长整型editor.putLong("Long", 1000000);// Float浮点数型editor.putFloat("Float", 3.5f);editor.commit(); SQLite特点： 也不支持一些标准的SQL功能，特别是外键约束（FOREIGNKEY constrains），嵌套transcaction和RIGHTOUTERJOIN和FULLOUTERJOIN，迓有一些ALTERTABLE功能。 和其他数据库最大的丌同就是对数据类型的支持 存储类型: 存储类 描述 NULL 值是一个NULL值 INTEGER 值是一个带符合的整数，根据值的大小存在1、2、3、4、6或8字节中。 REAL 值是一个浮点值，存储为8字节的IEEE浮点数字。 TEXT 值是一个文本字符串，使用数据库编码存储。 BLOB 值是一个blob数据，完全根据它的输入存储。 亲和类型亲和类型：TEXT、NUMERIC、REAL、INTEGER、NONE作用: 为了和其他DBMS以及SQL兼容，在create table中指定列类型时，SQLite会根据字段声明的类型，为其选择一种亲缘类型。 创建的数据库文件位于/data- /data/\/databases/&lt;数据库名&gt;.db ContentProvider作用： ContentProvider是Android平台中，在丌同应用程序乊间实现数据共享的唯一机制。 第九章socket与http的区别 socket不是协议是一个接口，http是一个协议 http对应于应用层，socket是对TCP/IP协议的封装，对应于传输层 http是短连接、socket是长连接 http状态码 用以表示服务器http响应状态 状态码 含义 100 客户端应当继续发送请求 | 200 | 成功 || 300 | 重定向 || 400 | 请求错误 || 403 | 拒绝访问 || 404 | 找不到资源 || 500 | 服务器错误 | socket三次握手确保双方都能成功连接到彼此 第一次握手：判断A到B方向是否通的第二次握手：确定A到B方向是通的，并开始判断B到A方向是否连通第三次握手：确定B到A方向是连通的 socket四次挥手保证断开连接时，传输数据的完整性 第一次挥手：A告诉B断开第二次挥手：B告诉A收到断开请求，但是可能数据还没传输完，所以等待数据传输完，所以告诉A等下。第三次挥手：B告诉A，可以断开了第四次挥手：A告诉B，好的 SAX全称：Simple API for XML。既是一种接口，也是一种软件包.它是xml解析的替代方式。 第十章进程与线程的区别 根本区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位。 进程之间的切换有很大消耗，而线程之间的切换开销小。 操作系统包括多个进程，而一个进程包含多个线程。 进程定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元。 进程间的通信：使用Binder实现 线程定义：线程是进程中的一个实体，将程序的执行和资源分开，一个进程可拥有多个线程。 Android的线程模型单线程模型一个进程中只能有一个线程在运行，剩下的线程必须等待当前的线程执行完再执行。 线程安全当多个线程访问一个类时，如果不考虑这些线程运行时的调度和交替执行，并且不需要额外的同步，这个类的行为仍然是正确的。那么称这个类是线程安全的。 Handler的基本概念定义：Handler类是Android系统为开发者封装的一个能异步处理消息的辅助类。 创建流程 得到Looper对象，得到MessageQueue对象（Looper.prepare()方法内部完成这两件事）。 实例化Handler并复写handleMessage()方法，用来接收传递过来的消息，并作相应处理。 调用loop()方法死循环获得消息队列的变化，并分发消息，最终回调HandleMessage()。 注意： 在activity启动的过程中，主线程已经调用了Looper.prepare()和Looper.loop()方法，所以我们只需要实例化Handler。 在UI线程使用Handler h = new Handler();时，系统默认将Looper的对象和MessageQueue关联到UI线程。若加入非UI线程，系统不会调用Looper的prepare()方法 AsyncTask 核心方法 作用 调用时刻 备注 execute(Params …params) 触发执行异步线程任务 手动调用 必须运行在主线程 onPreExecute() 执行线程任务前的操作(根据需求重写) 执行execute前自动调用 用于界面的初始化 doInBackground(Params …params) 执行任务（必须重写） 执行onPreExecute后自动调用 不能更改UI，可调用publishProgress()更新UI onProgressUpdate(Progress value) 在主线程中更新任务执行的进度 调用publishProgress()后，自动调用 – onPostExecute(Result result) 接收线程任务执行结果、将执行结果更新到UI组件 线程任务结束时自动调用 – onCancelled() 将异步任务设置为取消状态 异步任务被取消时自动调用 该方法被调用后，onPostExecute就不会被调用 第十二章操作系统 概念：任何计算机系统都包含一个基本的程序集合 目的：与硬件交互，管理所有的硬件资源为用户程序提供一个良好的执行环境 堆栈 作用：1：传递参数2：保存函数调用时的上下文 堆栈：存放函数的参数值，局部变量的值等常量区：字符串常量和其他常量的存储位置 用户态与内核态区分用户态和内核态： 禁止用户程序和底层硬件直接打交道 禁止用户程序访问任意的物理内存 中断与异常 中断：异步的，由硬件随机产生，在程序执行的任何时刻都有可能产生中断。 异常：同步的，在指令执行时由CPU控制单元产生。 系统调用 操作系统为用户态进程与硬件设备进行交互提供了一组接口 第十三章 GNU：一个类似 Unix ,且为 自由软件 的完整的操作系统。其使用Linux内核 GCC：GNU Compiler Collection，符合ISO等标准的C编译器 Make：是一种代码维护工具，在使用GNU编译器开发大型应用时，往往要使用make管理项目。 makefile：Makefile告诉make该做什么、怎么做 第十四章实模式X86复位后工作在实模式下，该模式下CPU的寻址空间为1M。CPU复位（reset）或加电（power on）的时候就是以实模式启动。在实模式下，不能访问20位以上的地址线，也就是只能访问1M内存。所以用于加载操作系统，然后进入保护模式。 保护模式实模式下，程序员指定的地址就是物理地址。这样会带来程序的安全性问题。所以为了避免这个问题，提出了保护模式。保护进程地址空间。 Android的启动过程 Loader层进行Boot ROM 和 Boot Loader。 内核层创建0号进程：idle(swapper)，运行在内核中，是唯一一个没有通过fork和kernel_thread产生的进程。常常称为交换进程。 Native层创建init进程(1号进程)，而init进程是由idle通过kernel_thread创建的。它是系统中所有其他用户进程的祖先进程。Linux中所有的进程都是由init进程创建并运行的。在系统启动完后，init变为守护进程监视系统的其他进程。 然后创建受精卵进程 第十五章进程 进程描述符使用进程描述符地址标识一个进程，每个进程的Process ID(PID)都放在进程描述符的pid域中。 进程的创建do_fork -&gt; copy_process -&gt; alloc_pid fork 是 创建一个子进程，并把父进程的内存数据copy到子进程中。 vfork是 创建一个子进程，并和父进程的内存数据share一起用。 内核线程与普通进程的差别 每个内核线程执行一个单独指定的内核函数 只运行在内核态 只使用大于PAGE_OFFSET的线性地址空间 进程0所有进程的祖先叫做进程0 在系统初始化阶段由start_kernel()函数从无到有手工创建的一个内核线程 Init_task Init_thread_union 进程0最后的初始化工作创建init内核线程，此后运行cpu_idle，成为idle进程 进程1又称为init进程由进程0在start_kernel调用rest_init创建init进程PID为1，当调度程序选择到init进程时，init进程开始执行kernel_init ()函数 课堂测试fork返回值为0，则当前进程为子进程fork返回值非0，则当前进程为父进程，且返回的值为子进程的pid 调用fork创建一个子进程，然后让子进程和父进程分别输出fork的返回值 12345678910int i = 0;i = fork();if(i &lt; 0) &#123; printf("error in fork!"); exit(1);//fork出错退出&#125; else if(i == 0) &#123; printf("子进程返回%d", i);&#125; else &#123; pprintf("父进程返回%d", i);&#125; 连续3次调用fork， 然后让子进程和父进程分别输出fork的返回值和各自的pid，说明一共创建了几个进程？画出进程之间的创建关系（进程使用pid来标识） 1234567int pid1 = 0, pid2 = 0, pid3 = 0;pid1 = fork();pid2 = fork();pid3 = fork();printf("fork 返回值 pid1=%d，current process pid = %d", pid1, getPid());printf("fork 返回值 pid2=%d，current process pid = %d", pid2, getPid());printf("fork 返回值 pid3=%d，current process pid = %d", pid3, getPid()); 总共创建7个进程 第十七章NUMA名称：非统一内存访问架构作用：物理内存划分为若干个node 存储区作用：为了解决页框由于自身物理地址的原因，不能被一些任务所使用的限制。Linux将物理内存划分为区。 Linux将物理存储器分为4个区：ZONE_DMAZONE_DMA32(未使用)ZONE_NORMALZONE_HIGHMEN ZONE_DMA和ZONE_NORMAL区：包含存储器的常规页，通过把它们映射到线性地址空间的3GB以上，内核就可以直接访问了。ZONE_HIGHMEN区不能直接由内核访问。 外部碎片导致原因：频繁的请求和释放不同大小的一组连续页框，导致物理页框中分散许多小的空闲页框。 解决方法： 利用MMU（内存管理单元）把一组非连续的物理空闲空间映射到连续的线性地址空间。 用一种技术记录空闲连续页框的情况，以避免满足对小块的满足而将大块空闲块进行切割。 伙伴算法解决外部碎片 ➢ 把所有空闲页框分组为10（Linux2.6.26为11）个块链表，每个块链表分别包含大小为1，2，4，8，16，32，64，128，256和512个连续的页框➢ 每个块的第一个页框的物理地址是该块大小的整数倍⚫例如：大小为16个页框的块，其起址是16×4KB的倍数 伙伴算法对逻辑地址空间的页框进行管理，找到页框后，通过mem_map数组映射到页框对应的物理地址。 slab作用：内存分配机制，解决内部碎片 Slab 相当于内存池思想，且是为了解决内碎片而产生的，slab的核心思想是以对象的观点管理内存。 缺页异常内核只是通过mmap()调用 分配了一些线性地址空间给进程，并没有把实际的物理页框分配给进程。当通过线性地址空间区访问物理页框，而并没有物理页框对应这些线性地址空间时，就会引发缺页异常。 中断：中断是指来自CPU执行指令以外的事件发生后，处理机暂停正在运行的程序，转去执行处理该事件的程序的过程。 异常：异常是指源自CPU执行指令内部的事件发生后，处理机暂停正在运行的程序，转去执行该事件的过程。 中断上下文中断上下文不同于进程上下文中断或异常处理程序执行的代码不是一个进程它是一个内核控制路径，代表了中断发生时正在执行的代码。 中断分类： 可屏蔽中断 非屏蔽中断只有几个特定的危急事件才引起非屏蔽中断。如硬件故障或者掉电 异常分类： 处理器探测异常如：溢出、除0错 编程异常由编程者发出，通常称为‘软中断’。例如：系统调用。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AtomicXXX源码（一）]]></title>
    <url>%2F2019%2F10%2F19%2FAtomicXXX%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言本篇将会介绍AtomicBoolean、AtomicInteger、AtomicLong这三个原子类 作用这三个类是为了实现其对应类线程安全的一些操作。例如i++问题，这行代码包括三个步骤：读取i，将值+1，写入i。在执行这三个步骤的过程中，i都有可能被其他线程修改。那最终将会导致i的值出错。我们将这种问题称为状态依赖。状态依赖：变量下一个值依赖于前一个值，例如i = 5, i++; 最后i是多少，依赖于i初始值，这里i = 5,所以最终i = 6。 解决i++线程不安全问题AtomicInteger等三个类，为了解决i++类似的线程不安全问题，有两个核心点，一个是使用volatile保证值的可见性，另一个是CAS无锁式同步机制。其中CAS全称Compare and Swap（先比较再替换）。 源码分析初始化如果不清楚类的初始化顺序，请跳转☞。这三个类源码基本都是一样的，所以我把这三个类放一起记录。根据类的初始化顺序我们先看静态代码块 123456789private volatile int value;static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125;&#125; 如上述代码，AntomicInteger中有个value变量，该变量使用volatile修饰。 为什么会用这个修饰呢？ 对于volatile大家都很熟悉，它能够保证变量的可见性，也就是当一个线程对变量a做出改变时，另一个变量能够立马发现变量a的变化。而我们AtomicInteger使用CAS需要比较然后替换，如果是跟一个旧值比较，那有何意义（这是一个需要大家思考的问题）。 然后代码块中会调用unsafe.objectFieldOffset方法，这个方法就是获取某个属性在类中的偏移地址。获取到这个偏移地址后，我们就可以根据内存地址直接修改其内存中的值了。 对于静态代码块执行之后的构造方法我就不做过多的解释了，因为其构造函数没什么有意义的东西。 1234567891011121314/** * Creates a new AtomicInteger with the given initial value. * * @param initialValue the initial value */public AtomicInteger(int initialValue) &#123; value = initialValue;&#125;/** * Creates a new AtomicInteger with initial value &#123;@code 0&#125;. */public AtomicInteger() &#123;&#125; 方法分析 常用的getAndIncrement方法 123456789101112131415161718// AtomicInteger中的方法public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;// UnSafe类中的方法/** * var1: AtomicInteger对象的地址 * var2: 对象中int值的偏移地址 * var4: AtomicInteger中int变量的变化量 */public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 上述代码是一种典型的CAS自旋锁，所谓的自旋锁就是在别人修改的时候，自己一直循环访问是否能修改值，而不会被阻塞直到资源占用着释放资源才被唤醒。在上面的代码中，UnSafe的compareAndSwapInt是调用了C语言的原生代码。在compareAndSwapInt中，会进行比较。如果内存中的值跟预期的var5一样，则返回true，否则返回false直到内存中的值与预期的var5一样，才将var5 + var4写入内存中。 疑问 如果内存中的值与我们预期的var5一样，然后开始准备写入我们的var5 + var4时，内存中的值被人修改了怎么办？会发生这种情况吗？（这句话的意思能体会吗） 如果会发送图中的情况，那么AtomicInteger将不是线程安全的类。经过查找网上大家都说比较并替换是由硬件完成的，而这个操作是不会响应中断，所以保证了它的原子性。 IntUnaryOperator类 123456789101112131415161718/** * Atomically updates the current value with the results of * applying the given function, returning the previous value. The * function should be side-effect-free, since it may be re-applied * when attempted updates fail due to contention among threads. * * @param updateFunction a side-effect-free function * @return the previous value * @since 1.8 */public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev;&#125; 在AtomicInteger类中，只是定义了getAndIncrement和getAndDecrement等简单的操作。但是还有很多复杂的并且依赖之前的值的操作，比如value = value / 2等等，不可能全部实现在类中。所以AtomicInteger提供了一些函数接口，例如IntUnaryOperator用户实现该接口，并且在其中进行一些复杂的操作来完成需求。 简单的使用 1234567891011121314151617181920public class IntUnaryOperatorTest &#123; public static void main(String[] args) &#123; AtomicInteger num = new AtomicInteger(0); System.out.println(num.getAndUpdate(new Operator())); System.out.println(num.getAndUpdate(v -&gt; v * 100)); // lambda表达式写法， java8中的函数接口都可以用lambda表达式 &#125; &#125;class Operator implements IntUnaryOperator &#123; @Override public int applyAsInt(int operand) &#123; System.out.println("Hello----------------applyAsInt"); return operand + 100; &#125; &#125; compareAndSet和weakCompareAndSet 12345678910111213141516171819202122232425262728/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful. False return indicates that * the actual value was not equal to the expected value. */public final boolean compareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update);&#125;/** * Atomically sets the value to the given updated value * if the current value &#123;@code ==&#125; the expected value. * * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is * only rarely an appropriate alternative to &#123;@code compareAndSet&#125;. * * @param expect the expected value * @param update the new value * @return &#123;@code true&#125; if successful */public final boolean weakCompareAndSet(long expect, long update) &#123; return unsafe.compareAndSwapLong(this, valueOffset, expect, update);&#125; 在weakCompareAndSet注释中说，weakCompareAndSet不保证指令不会重排序，而且可能会替换失败。但是其调用的代码与compareAndSet一模一样，所以我猜测这个在功能上与compareAndSet，并未实现像其注释说的一样。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[concurrent包源码阅读开篇]]></title>
    <url>%2F2019%2F10%2F16%2Fconcurrent%E5%8C%85%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[前言前段时间认识了一个从事深度学习方向的博士学长，这个学长帮导师写一个项目临时要用java做开发。学长由于不太会java就问了我一个并发框架的问题，可是我这个声称是学java的却回答不上来。顿时觉得有种没学过java的感觉，为了以后不会发生这种尴尬，遂决心阅读concurrent包中的源码，并以此系列作为笔记。 并发面临的问题并发中常遇见的问题有原子性问题、可见性问题。其中由于jvm对代码的优化还带来了有序性问题。 原子性现代电脑处理器基本有多个内核，而每个内核上可以跑一个线程，所以电脑可以实现真正的并行运算。而两个并行运算的线程难免有所交集处理了一个变量。就如下面的情况，这样线程A得到的值最后竟然是0。有时候出现这种情况是致命性的，所以为了避免这种情况发送我们要确保对变量a进行处理和赋值的过程是原子性的，不能被中断。 在java中如果要实现原子性可以对操作进行加锁，例如使用synchronized和Lock。同过这些锁，可以使一个代码块或者对象只能被一个线程使用，其他线程只能等使用者用完。 可见性在java的线程内存模型中，线程会共享本进程分配得到的内存。而每个线程会有属于自己的工作内存（工作内存线程之间不共享），他们会把一些共享变量拷贝到自己的工作内存。对共享变量进行操作时，会首先对自己工作内存进行操作，所以线程a看不到线程b对共享变量的操作，除非将线程b的工作内存刷新到主内存中，线程a才能看到（什么时候刷新我不太清楚，知道的大佬可以教教我）。 正是因为线程a可能看不到线程b对变量的改变，就产生了变量的可见性问题。例如可以执行如下代码：12345678910111213141516171819202122public class Main &#123; static boolean flag = true; public static void main(String[] args) throws InterruptedException &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; while(flag) &#123; &#125; System.out.println(Thread.currentThread() + "中的循环结束了"); &#125; &#125;, "检测Flag的线程").start(); Thread.sleep(1000); flag = false; System.out.println("flag的值为" + flag); &#125;&#125; 解决共享变量的可见性问题就是使用volatile。具体详情可以参考https://www.cnblogs.com/monkeysayhi/p/7654460.html可以将class文件反编译成汇编语言进行验证。 下期，将会写读并发包源码的笔记]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>源码</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2019%2F09%2F24%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 假设系统中存在一个对象A被频繁的创建。如果某一天，需求发生变化，我们要重新改变对象A的创建的时候，发现A在几十个甚至上百个java文件中创建了。我们该怎么办？一个一个修改吗？ 当我们遇见这种经常使用的对象时，就该想想是否是要用到工厂模式了。为了少加班做无用功，让我们看看工厂模式是怎么解决这种问题的。 假设背景假设我们刚开始时建一个只有高度和宽度的手机类。然后创建N个手机类对象。突然，产品锦鲤要我们给手机类加上颜色属性。 未用工厂模式刚开始建的手机类 123456789101112131415161718192021/** * 未上色的手机类 */public class Phone &#123; private int width; private int height; public Phone(int width, int height) &#123; this.width = width; this.height = height; &#125; @Override public String toString() &#123; return "Phone&#123;" + "width=" + width + ", height=" + height + '&#125;'; &#125;&#125; 手机类建好了，我们开始生产手机把 123456789101112public class Main &#123; public static void main(String[] args) &#123; Phone phone1 = new Phone(15,10); Phone phone2 = new Phone(15,10); Phone phone3 = new Phone(15,10); Phone phone4 = new Phone(15,10); Phone phone6 = new Phone(15,10); Phone phone7 = new Phone(15,10); Phone phone8 = new Phone(15,10); &#125;&#125; 生产了一批没上色的手机，这个时候，产品锦鲤要求手机要加个颜色属性，并且构建的时候就要初始化。加吧。 1234567891011121314151617181920212223/** * 上色的手机类 */public class Phone &#123; private int width; private int height; private String color; public Phone(int width, int height, String color) &#123; this.width = width; this.height = height; this.color = color; &#125; @Override public String toString() &#123; return "Phone&#123;" + "width=" + width + ", height=" + height + '&#125;'; &#125;&#125; 可是回头看Main方法（生产手机的地方） 发现使用之前构造手机的方法不行了，我们要把它们一个一个加上颜色。在这里我们还只是用了8次而且都在一个文件中。如果真的在开发环境中，一个类用了几十次，并且都分布在不同的文件中，突然发现要给类加东西怎么办？ 所以在项目中发现存在这种对象存在，就要考虑是否要用工厂模式来生产该对象了。下面我们看看使用简单工厂模式。 简单工厂模式我们先用只有高度和宽度属性的手机类，然后在简单工厂模式创建手机类 12345public class PhoneFactory &#123; public static Phone createPhone() &#123; return new Phone(10, 15); &#125;&#125; 在主方法中使用PhoneFactory创建Phone对象 1234567891011public class Main &#123; public static void main(String[] args) &#123; Phone phone = PhoneFactory.createPhone(); Phone phone1 = PhoneFactory.createPhone(); Phone phone2 = PhoneFactory.createPhone(); Phone phone3 = PhoneFactory.createPhone(); Phone phone4 = PhoneFactory.createPhone(); &#125;&#125; 然后我们给Phone类加上颜色属性。这个时候我们发现PhoneFactory中创建Phone报错，但是主方法中由于未直接使用Phone的构造方法，所以当Phone的构造方法发生改变时，主方法也不会报错。这样整个项目就只有PhoneFactory一处报错，我们就很容易修改。 修改如下 123456public class PhoneFactory &#123; public static Phone createPhone() &#123; return new Phone(10, 15, "黑色"); &#125;&#125; 问题 但是使用简单工厂模式有几个缺点： 不符合开闭原则。 当我们需要添加新的类由工厂创建的时候，我们需要修改原来的PhoneFactory类。 臃肿 当PhoneFactory类中加入了大量的创建对象方法后，PhoneFactory会变得及其臃肿。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象方法模式]]></title>
    <url>%2F2019%2F09%2F24%2F%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言 现实生活中，许多事务的处理步骤是固定的，但是每步详细的处理方法可能不尽相同。 例如：我们在外面回家时就要经历两个步骤。 第一步：买车票 第二步：坐车 假如我们不使用抽象方法模式写一个乘坐火车（Train）和乘坐大巴（bu）回家的流程： 123456789101112131415161718/** * 坐大巴回家 */public class GoHomeByBus &#123; public void buyTicket() &#123; System.out.println("去汽车站买汽车票"); &#125; public void sitCar() &#123; System.out.println("去汽车站坐车"); &#125; public void goHome() &#123; buyTicket(); sitCar(); &#125;&#125; 1234567891011121314151617/** * 坐火车回家 */public class GoHomeByTrain &#123; public void buyTicket() &#123; System.out.println("去火车站买火车票"); &#125; public void sitCar() &#123; System.out.println("去火车站坐车"); &#125; public void goHome() &#123; buyTicket(); sitCar(); &#125;&#125; 冗余问题 会发现我们在两种回家的类中都写了goHome方法，而且由于回家的流程一样，所以该方法的内容都一样，如果还需要添加其他的回家方式，就会造成了更多冗余。 解决冗余 所以我们可以提取一个GoHome类，将goHome方法写在GoHome类中，然后让描述不同回家方式的类继承GoHome，那么就很好解决了冗余的问题。 因为我们要将goHome方法写在GoHome类中，而goHome调用的方法在GoHome类中不存在，所以我们也要将其调用的方法上升到GoHome类中。而这几个方法是与回家方式相关的，所以将它们声明为abstract方法，让子类去实现。 UML图 具体代码 回家抽象类 1234567891011121314151617public abstract class GoHome &#123; /** * 买车票 */ public abstract void buyTicket(); /** * 坐车回家 */ public abstract void sitCar(); public void goGome() &#123; buyTicket(); sitCar(); &#125;&#125; 坐火车回家类 123456789101112public class GoHomeByTrain extends GoHome &#123; @Override public void buyTicket() &#123; System.out.println("去火车站买火车票"); &#125; @Override public void sitCar() &#123; System.out.println("去火车站坐车"); &#125;&#125; 坐大巴回家类1234567891011public class GoHomeByBus extends GoHome &#123; @Override public void buyTicket() &#123; System.out.println("去汽车站买汽车票"); &#125; @Override public void sitCar() &#123; System.out.println("去汽车站坐车"); &#125;&#125; 总结上面提出一个GoHome基类的实现方式就是利用抽象方法模式，抽象方法模式的核心思想就是将一件事的固定处理步骤的实现提取到基类中（如goHome方法），然后子类继承积累，并且子类只需要实现各个步骤的处理方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有趣的函数接口]]></title>
    <url>%2F2019%2F09%2F06%2F%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[前言在看spring源码路径解析的时候，遇见了helper.replacePlaceholders(text, this::getPropertyAsRawString);。这里有个很奇怪的this::getPropertyAsRawString。::这个符号在C++中很眼熟，但是在java中还是第一次见（是我太菜没怎么学过java8，后面一定要补上。先在此记录。）,也不知道传了什么东西过去。 在好奇心的促使下，我点进了方法replacePlaceholders发现参数列表为1234public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) &#123; Assert.notNull(value, "'value' must not be null"); return parseStringValue(value, placeholderResolver, null);&#125; 发现第二个参数是PlaceholderResolver类型，而这个类型是一个FunctionalInterface接口，其源码如下： 1234567891011121314/** * Strategy interface used to resolve replacement values for placeholders contained in Strings. */@FunctionalInterfacepublic interface PlaceholderResolver &#123; /** * Resolve the supplied placeholder name to the replacement value. * @param placeholderName the name of the placeholder to resolve * @return the replacement value, or &#123;@code null&#125; if no replacement is to be made */ @Nullable String resolvePlaceholder(String placeholderName);&#125; 问题：FunctionalInterface注解作用如这个注解的名字所示，这个接口只是向大家声明该接口是一个函数接口。而声明为函数接口，有如下要求： 只能有一个抽象函数(但是有例外，详情见下)。 可以有default修饰的方法，因为default修饰的方法是已经实现了的 函数接口中抽象函数可以有多个，但是除了自定义的抽象函数之外的抽象函数必须是Object中已实现的方法。（如：下面的代码） 12345678910111213@FunctionalInterfacepublic interface PlaceholderResolver &#123; String resolvePlaceholder(String placeholderName); default void print() &#123; System.out.println("hh "); &#125; public String toString(); public boolean equals(Object obj);&#125; 如果不是Object中已经实现的方法，则会报错。如下图： 知道函数接口的定义后，那函数接口怎么使用呢？以及他的作用 使用步骤定义一个函数接口12345@FunctionalInterfacepublic interface PlaceholderResolver &#123; String resolvePlaceholder();&#125; 定义一个将函数接口作为参数的方法123public void test(PlaceholderResolver placeholderResolver) &#123; placeholderResolver.resolvePlaceholder();&#125; 在定义一个方法1234public String print() &#123; System.out.println("我是print方法") return str;&#125; 现在就可以愉快的使用了123public void test() &#123; test(this::print);&#125; 而上面调用test方法后就会输出在执行placeholderResolver.resolvePlaceholder(“啦啦啦”);时输出我是print方法。其作用也就是将print方法赋给PlaceholderResolver中的resolvePlaceholder，所以在调用resolvePlaceholder方法会执行print。 最后究其到底函数接口只是一个语法糖，它是java8一个新的语法糖。它的效果等价于： 1234567public void test() &#123; test(new PlaceholderResolver() &#123; public String resolvePlaceholder() &#123; print(); &#125; &#125;)&#125; 所以在调用resolvePPlaceholder方法时会调用print方法。这样使用函数接口替代匿名内部类，可以是代码更加简洁。但要注意的是print方法要和resolvePlaceholder方法的参数列表、返回参数一致，方法名可以不一致。]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ant风格]]></title>
    <url>%2F2019%2F09%2F01%2FAnt%E9%A3%8E%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[前言在阅读dalao的文章时，看到支持Ant风格。遂对Ant风格产生了好奇。遂写此blog以做笔记。 Ant风格：就是匹配路径和url的一种规则。例如：我们常见的C:/project/*.html匹配C盘目录下project文件夹中的所有html文件。 规则 符号 说明 ? 匹配任何单字符 * 匹配0或者任意数量的字符 ** 匹配0或者更多的目录 例如URL路径 | 说明–|–:/project/.a|匹配项目根路径下所有在project路径下的.a文件/project/p?ttern|匹配项目根路径下 /project/pattern 和 /app/pXttern,但是不包括/app/pttern//example|匹配项目根路径下 /project/example, /project/foow/example, 和 /example/project//dir/file.|匹配项目根路径下/project/dir/file.jsp, /project/foow/dir/file.html,/project/foow/bar/dir/file.pdf/*/.jsp|匹配项目根路径下任何的.jsp 文件 注意：如果一个路径存在多个匹配，那么将选择最长的匹配。例如：URL请求/project/dir/file.jsp，现在存在两个路径匹配模式/*/.jsp和/project/dir/.jsp，那么会根据模式/project/dir/.jsp来匹配]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[schemaLocation值必须具有偶数个URI]]></title>
    <url>%2F2019%2F09%2F01%2FschemaLocation%E5%80%BC%E5%BF%85%E9%A1%BB%E5%85%B7%E6%9C%89%E5%81%B6%E6%95%B0%E4%B8%AAURI%2F</url>
    <content type="text"><![CDATA[前言学习并使用spring框架开发已经有了一段很长的时间了，但是之前没有把在学习过程中遇见关于spring的错误积累下来。所以从现在开始，将在此开辟一博客收集我遇见的奇葩错误。 错误一 SchemaLocation: schemaLocation 值必须具有偶数个 URI 该错误是我在学习ignoreDependencyInterface和ignoreDependencyType之间的区别及使用的时候发现的。 我在配置spring的beans.xml时，设置context:annotation-config&lt;/context:annotation-config&gt;。发现要在beans标签中加入xmlns:context=”http://www.springframework.org/schema/context&quot;。（因为我们要用到context标签所以要引入context） 加入后运行。 代码提示报错 12345678910111213141516Exception in thread "main" org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 52 in XML document from file [C:\Users\Administrator\Downloads\adaptive-loadbalance-master-154377df0a8f753f2ea462ec15a6f76f882691bc\study\src\main\resources\META-INF\spring\camel-context.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 52; columnNumber: 30; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 'context:annotation-config' 的声明。 at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:404) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:336) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:195) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:257) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:128) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:94) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:133) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:636) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:521) at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:142) at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:85) at study.Application.main(Application.java:11) 原因是因为在12xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd" 中要加入12http://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd 刚开始年轻的我只加入了一个1http://www.springframework.org/schema/context 导致报错1org.xml.sax.SAXParseException: SchemaLocation: schemaLocation 值 'http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd http://www.springframework.org/schema/context' 必须具有偶数个 URI。 总结通过这次错误，我们可以知道要在beans.xml中加入一个标签的流程如下（以context为例）： 第一步：加入1xmlns:context="http://www.springframework.org/schema/context" 第二步：在xsi:schemaLocation中加入1http://www.springframework.org/schema/context 第三步：在xsi:schemaLocation中加入1http://www.springframework.org/schema/spring-context.xsd]]></content>
      <categories>
        <category>错误</category>
      </categories>
      <tags>
        <tag>spring错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[StringBuffer神秘的toStringCache属性]]></title>
    <url>%2F2019%2F08%2F17%2FStringBuffer%E7%A5%9E%E7%A7%98%E7%9A%84toStringCache%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言 大家都知道直接对String字符串进行拼接等操作时，会创建大量的String对象。因此用String直接进行这些操作效率会很低。所以催生了StringBuilder和StringBuffer这两个类。这两个类基本相同，但是StringBuffer多了一个toStringCache变量（后面具体讲解该变量作用），并在方法体上加了synchronized。 StringBuilder和StringBuffer的相同点 都继承于AbstractStringBuilder类。 都实现了java.io.Serializable, CharSequence接口。 字符串都是存储在一个字符数组中。StringBuilder和StringBuffer不同点一 StringBuffer是线程安全的，而StringBuilder是线程不安全的。那StringBuffer是怎么实现线程安全的呢？通过源码的对比，可以看到两个类的实现大致相同，不一样的就是StringBuffer在方法体加了synchronized。 StringBuilder和StringBuffer不同点二 在对比两个类的源码，发现StringBuffer多了一个toStringCache12345/** * A cache of the last value returned by toString. Cleared * whenever the StringBuffer is modified. */ private transient char[] toStringCache; 这个属性的作用是缓存toString方法返回的最后一个值，当StringBuffer对象被修改时，这个变量都会被设置为NULL。 toStringCache的作用 众所周知对字符串的操作效率StringBuilder &gt; StringBuffer &gt; String也就是说StringBuffer的效率并不是最棒的，所以仍需提高，设置toStringCache的作用就是为了提高效率 问题来了：toStringCache是怎么提高效率的 先看看StringBuilder和StringBuffer两个类中的toString方法 StringBuffer的toString方法1234567@Overridepublic synchronized String toString() &#123; if (toStringCache == null) &#123; toStringCache = Arrays.copyOfRange(value, 0, count); &#125; return new String(toStringCache, true);&#125; StringBuilder的toString方法12345@Overridepublic String toString() &#123; // Create a copy, don't share the array return new String(value, 0, count);&#125; 从两个方法中可以看到StringBuffer已经将方法重写为了synchronized方法，已经实现了线程安全，可是方法的具体实现却不同。 两个方法创建String的方法分别为： new String(toStringCache, true); –对应的构造方法–&gt; String(char[] value, boolean share)new String(value, 0, count); –&gt;对应的构造方法–&gt; String(char value[], int offset, int count) 所以现在需要去了解两个构造方法的不同 12345678910111213public String(char value[], int offset, int count) &#123; //此处省略一部分代码 ...... this.value = Arrays.copyOfRange(value, offset, offset+count); //复制数组到value &#125;&#125;//完整的函数，就是这么简单粗暴String(char[] value, boolean share) &#123; // assert share : "unshared not supported"; this.value = value;&#125; 从上面可以看出调用String(char[] value, boolean share) 不用复制数组调用String(char value[], int offset, int count) 需要复制数组 再回到StringBuffer和StringBuilder的toString方法就知道StringBuffer只有当toStringCache是NULL的时候（也就是当字符串发生变化）需要复制数组，而StringBuilder的toString方法每次创建String都要复制数组。所以现在清楚了toStringCache就是这样提高一点点效率。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Spring中Bean的生命周期]]></title>
    <url>%2F2019%2F07%2F22%2FSpring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[我们都知道Spring的IOC容器帮我们管理着Bean，我们可以从IOC容器中拿到我们想要的Bean对象。但是IOC是如何管理我们的Bean呢？下面将会从源码分析的角度来介绍Spring中Bean的生命周期。 BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解) 12345678910111213141516171819202122232425/** * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces * as far as possible. The full set of initialization methods and their standard order is:&lt;br&gt; * 1. BeanNameAware's &#123;@code setBeanName&#125;&lt;br&gt; * 2. BeanClassLoaderAware's &#123;@code setBeanClassLoader&#125;&lt;br&gt; * 3. BeanFactoryAware's &#123;@code setBeanFactory&#125;&lt;br&gt; * 4. ResourceLoaderAware's &#123;@code setResourceLoader&#125; * (only applicable when running in an application context)&lt;br&gt; * 5. ApplicationEventPublisherAware's &#123;@code setApplicationEventPublisher&#125; * (only applicable when running in an application context)&lt;br&gt; * 6. MessageSourceAware's &#123;@code setMessageSource&#125; * (only applicable when running in an application context)&lt;br&gt; * 7. ApplicationContextAware's &#123;@code setApplicationContext&#125; * (only applicable when running in an application context)&lt;br&gt; * 8. ServletContextAware's &#123;@code setServletContext&#125; * (only applicable when running in a web application context)&lt;br&gt; * 9. &#123;@code postProcessBeforeInitialization&#125; methods of BeanPostProcessors&lt;br&gt; * 10. InitializingBean's &#123;@code afterPropertiesSet&#125;&lt;br&gt; * 11. a custom init-method definition&lt;br&gt; * 12. &#123;@code postProcessAfterInitialization&#125; methods of BeanPostProcessors * * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;br&gt; * 1. DisposableBean's &#123;@code destroy&#125;&lt;br&gt; * 2. a custom destroy-method definition **/ 注释翻译（翻译错的请轻喷）Bean工厂的实现者应该尽可能支持标准的Bean生命周期接口。Bean的初始化方法和他们标准的执行顺序如下：1.BeanNameAware的setBeanName方法2.BeanClassLoaderAware的setBeanClassLoader方法3.BeanFactoryAware的setBeanFactory方法4.ResourceLoaderAware的setResourceLoader方法5.ApplicationEventPublisherAware的setApplicationEventPublisher方法6.MessageSourceAware的setMessageSource方法7.ApplicationContextAware的setApplicationContext方法8.ServletContextAware的setServletContext方法9.BeanPostProcessors的postProcessAfterInitialization方法初始化完毕 -&gt; 进行我们的业务操作Bean的关闭生命周期调用方法1.DisposableBean的destroy方法2.在配置文件中指定的destroy-method方法 看完这个注释后，我们将回到源码找到Bean执行以上方法的地方。通过调试我们可以找到执行上述步骤的方法为initializeBean方法。123456789101112131415161718192021222324252627282930protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, "Invocation of init method failed", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 上面的代码就为该方法，我将该方法分为四部分。 第一部分执行所有的Aware方法也就是上面提到的invokeAwareMethods方法该方法将XXXAware对应的XXX对象传给bean。例如BeanNameAware就会将beanName传给bean。12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; 第二部分执行Bean后置处理器的postProcessBeforeInitialization方法Bean后置处理器也就是BeanPostProcessor的实现类。也就是initializeBean方法中applyBeanPostProcessorsBeforeInitialization调用。在applyBeanPostProcessorsBeforeInitialization方法中，Spring将遍历执行系统自带的和用户定义的所有Bean后置处理器。12345678910public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) throws BeansException &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; 第三部分执行Bean的Init方法在这里首先会判断Bean是否继承了InitializingBean接口如果继承了InitializingBean接口，就调用InitializingBean接口的afterPropertiesSet方法。然后判断用户在配置Bean的时候是否指定了init方法（xml配置为指定init-method，注解配置为PostConstruct）。如果指定了就调用。123456789101112131415161718192021222324252627282930313233protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd) throws Throwable &#123; boolean isInitializingBean = (bean instanceof InitializingBean); if (isInitializingBean &amp;&amp; (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'"); &#125; if (System.getSecurityManager() != null) &#123; try &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((InitializingBean) bean).afterPropertiesSet(); return null; &#125; &#125;, getAccessControlContext()); &#125; catch (PrivilegedActionException pae) &#123; throw pae.getException(); &#125; &#125; else &#123; ((InitializingBean) bean).afterPropertiesSet(); &#125; &#125; if (mbd != null) &#123; String initMethodName = mbd.getInitMethodName(); if (initMethodName != null &amp;&amp; !(isInitializingBean &amp;&amp; "afterPropertiesSet".equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123; invokeCustomInitMethod(beanName, bean, mbd); &#125; &#125;&#125; 第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步 到此Bean的初始化就完成了。后面就是Bean的销毁销毁跟初始化调用Bean的init方法一样，不过在销毁的时候是判断Bean是否实现了DisposableBean接口，如果实现了就调用DisposableBean的destroy方法。然后在判断Bean是否指定了销毁方法（xml方式是destroy-method，注解方式是@PreDestroy） 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void destroy() &#123; if (!CollectionUtils.isEmpty(this.beanPostProcessors)) &#123; for (DestructionAwareBeanPostProcessor processor : this.beanPostProcessors) &#123; processor.postProcessBeforeDestruction(this.bean, this.beanName); &#125; &#125; if (this.invokeDisposableBean) &#123; if (logger.isDebugEnabled()) &#123; logger.debug("Invoking destroy() on bean with name '" + this.beanName + "'"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Object&gt;() &#123; @Override public Object run() throws Exception &#123; ((DisposableBean) bean).destroy(); return null; &#125; &#125;, acc); &#125; else &#123; ((DisposableBean) bean).destroy(); &#125; &#125; catch (Throwable ex) &#123; String msg = "Invocation of destroy method failed on bean with name '" + this.beanName + "'"; if (logger.isDebugEnabled()) &#123; logger.warn(msg, ex); &#125; else &#123; logger.warn(msg + ": " + ex); &#125; &#125; &#125; if (this.destroyMethod != null) &#123; invokeCustomDestroyMethod(this.destroyMethod); &#125; else if (this.destroyMethodName != null) &#123; Method methodToCall = determineDestroyMethod(); if (methodToCall != null) &#123; invokeCustomDestroyMethod(methodToCall); &#125; &#125;&#125; Bean的生命周期总结 调用XXXAware方法的setXXX–&gt;调用Bean后置处理器的postProcessBeforeInitialization–&gt;调用InitializingBean接口的afterPropertiesSet方法–&gt;调用用户指定的初始方法–&gt; 业务 –&gt;调用DisposableBean接口的destory方法–&gt;调用用户指定的销毁方法]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BeanFactory、FactoryBean、ObjectFactory的区别]]></title>
    <url>%2F2019%2F07%2F21%2FBeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[这三个类都属于org.springframework.beans.factory包下，并且名字都有点相似，但在功能上却大部相同。具体有哪些不同呢？下面将从这三个类的功能与用法分别分析。 BeanFactory 该类名以Factory结尾，其实质为一个Bean工厂接口，源码如下。从源码可以看出这个接口定义了Bean工厂的一些基本操作。所以这个接口起到了规范Bean工厂的基本操作作用。其基本实现有HierarchicalBeanFactory、ListableBeanFactory和ConfigurableBeanFactory以及各种ApplicationContext等等。如果想看BeanFactory的基本实现可以去看ListableBeanFactory的源码。而BeanFactory的使用则推荐使用ApplicationContext的一些派生类（如FileSystemXmlApplicationContext以及AnnotationConfigApplicationContext等类） 1234567891011121314151617public interface BeanFactory &#123; String FACTORY_BEAN_PREFIX = "&amp;"; // 这个与FactoryBean有关，后面会介绍到 Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; //是否是多例的意思 boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); // 获取Bean的别名&#125; FactoryBean 该类以Bean结尾，自然就是一个Bean，但这个Bean不是普通的Bean。这个Bean的设计类似于工厂模》&gt;式，专门用于创建特定的对象。可是Spring控制反转不是把对象的创建控制权交给了BeanFactory进行管理吗？那是因为有些创建比较复杂的类用配置文件来描述初始化不方便（Bean工厂要读取xml或者注解形式的类的初始化相关属性，这样Bean工厂才知道怎么帮我们创建该对象）。源码如下。 123456789public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;?&gt; getObjectType(); boolean isSingleton();&#125; getObject方法便是这个FactoryBean创建对象的地方。调用这个方法就可以获取他创建的一个对象。 使用方法（本次只展示xml方式） 展示中涉及三个类Test类：main方法Car类：FactoryBean中构建的。CarFactoryBean类：继承了FactoryBean专用来构建Car的。 Car 123456public class Car &#123; @Override public String toString() &#123; return "I'm Car"; &#125;&#125; CarFactoryBean在getObject方法中构建Car对象。 123456789101112131415161718192021class CarFactoryBean implements FactoryBean&lt;Car&gt; &#123; public Car getObject() throws Exception &#123; //FactoryBean专门用来创建初始化复杂的对象 //此处假设在进行很复杂的构造对象 return new Car(); &#125; public Class&lt;?&gt; getObjectType() &#123; return Car.class; &#125; public boolean isSingleton() &#123; return false; &#125; @Override public String toString() &#123; return "I'm CarFactory"; &#125;&#125; 配置文件beans.xml。 注意此处name为bean对应的是CarFactoryBean,等下注意使用getBean方法获取的对象是什么。 12345678&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt; &lt;bean name="bean" class="com.test.CarFactoryBean"/&gt;&lt;/beans&gt; Test 123456789public class Test &#123; public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext("beans.xml"); Object obj1 = ctx.getBean("car"); System.out.println(obj1); Object obj2 = ctx.getBean("&amp;car");// 注意这里的区别 System.out.println(obj2); &#125;&#125; 最后输出的结果如下 所以大家发现了没，在配置文件中我们配置的是car对应CarFactoryBean对象的，但是在getBean(“car”)时，取到的却是Car对象。这正是FactoryBean作用之处，在getBean中自动的调用了FactoryBean的getObject方法，并将FactoryBean构建的对象返回。如果想得到的是CarFactoryBean对象呢？那就要在car前面加个&amp;符号(心细的同学可能记得前面BeanFactory源码中也提到了&amp;符号，其作用就是这个）。 通过Debug看源码可以看出在AbstractBeanFactory类中的getObjectForBeanInstance方法 12345678910111213141516171819202122232425262728293031protected Object getObjectForBeanInstance( Object beanInstance, String name, String beanName, RootBeanDefinition mbd) &#123; if (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance instanceof FactoryBean)) &#123; throw new BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass()); &#125; //判断是否实现了FactoryBean接口， //如果没实现就返回bean对象。 if (!(beanInstance instanceof FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123; return beanInstance; &#125; Object object = null; if (mbd == null) &#123; //如果实现了FactoryBean对象 //则从FactoryBean中调用getObject方法获取对象 object = getCachedObjectForFactoryBean(beanName); &#125; if (object == null) &#123; // Return bean instance from factory. FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance; // Caches object obtained from FactoryBean if it is a singleton. if (mbd == null &amp;&amp; containsBeanDefinition(beanName)) &#123; mbd = getMergedLocalBeanDefinition(beanName); &#125; boolean synthetic = (mbd != null &amp;&amp; mbd.isSynthetic()); object = getObjectFromFactoryBean(factory, beanName, !synthetic); &#125; return object;&#125; ObjectFactory 跟FactoryBean一样，用工厂模式创建对象。源码如下。那么竟然与FactoryBean类似，都是用于创建对象。那两者有什么区别呢？我们注意到FactoryBean中还具有isSingleton、getObjectType等方法。这些方法是专门用于bean工厂的。从这个接口的注释也可以得出FactoryBean是专为BeanFactory所设计（This interface is similar to {@link FactoryBean}, but implementations of the latter are normally meant to be defined as SPI instances in a {@link BeanFactory}）。因此ObjectFactory只是一个普通的工厂模式中的工厂接口。 1234567891011121314151617181920212223242526/** * Defines a factory which can return an Object instance * (possibly shared or independent) when invoked. * &lt;p&gt;This interface is typically used to encapsulate a generic factory which * returns a new instance (prototype) of some target object on each invocation. * &lt;p&gt;This interface is similar to &#123;@link FactoryBean&#125;, but implementations * of the latter are normally meant to be defined as SPI instances in a * &#123;@link BeanFactory&#125;, while implementations of this class are normally meant * to be fed as an API to other beans (through injection). As such, the * &#123;@code getObject()&#125; method has different exception handling behavior. * * @author Colin Sampaleanu * @since 1.0.2 * @see FactoryBean */public interface ObjectFactory&lt;T&gt; &#123; /** * Return an instance (possibly shared or independent) * of the object managed by this factory. * @return an instance of the bean (should never be &#123;@code null&#125;) * @throws BeansException in case of creation errors */ T getObject() throws BeansException;&#125;]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2019%2F06%2F06%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机常见英语单词翻译]]></title>
    <url>%2F2019%2F04%2F26%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"></content>
      <categories>
        <category>大杂烩</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云环境下配置Nginx的SSL证书]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[阿里云服务器Nginx环境下配置SSL证书HTTPS的认识### HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 &#8194;&#8194;一般我们的服务器默认使用http协议，而https协议则需要自己配置协议，所以当在浏览器输入栏输入域名前加https时，会显示无法访问（如图1-1所示)。所以本次我将记录下在阿里云服务器Nginx环境下配置https协议过程。如在其他云运行商，亦可参考。 第一步：下载SSL证书 SSL证书分为收费版和免费的，作为一个土豆丝，我只能申请免费版的ssl证书，为期一年，但是可以无限申请。至于在哪里下呢。请按如下步骤。 进入域名的云解析控制台 （当然，前提是咱们有个域名）界面如图（2-1）所示 在你要配置SSL证书的那一项点击旁边的更多，然后又一个SSL证书按钮（如图2-2），点击它。 申请Symantec DV SSL证书 在阿里云平台中该证书是免费的，但是期限只有一年，一年后过期可再来申请。如图2-3填写要申请的域名，刚开始我输入*想为所有二级域名配置ssl证书，但是发现申请的按钮是灰的。后来发现输入www则没事，输入别的应该也可以吧，大家可以试试。 填写验证信息 大家在这里可能会遇见图2-4这种错误，但是大家不要方。刚开始我也遇见了，后来发现他是在域名解析规则中添加了一个主机记录为_dnsauth的解析规则。而域名解析规则更新到dns服务器上要等一会儿，所以大家乘这个机会喝杯茶，等下点击验证就ojbk。 下载证书 上一步验证成功后，就会跳转到SSL证书下载页面（如图2-5）。大家根据自己的需求下载对应的证书就可以了，我是要配置Nginx的SSL证书所以这里我选择了Nginx版的。到此第一阶段就结束了。 第二步：配置Nginx将证书上传服务器 我先将下载的压缩包解压开，然后里面会有一个pem和key文件。然后通过scp命令（命令如下）将该软件上传到服务器的Nginx配置文件夹中的一个文件夹(SSL文件夹，这个文件夹是我自己建的，大家可以上传到自己喜欢的目录中) 123scp -r 2020586_www.butong.live.key 2020586_www.butong.live.pem root@www.butong.live:/etc/nginx/ssl//格式scp -r 文件[ 文件] 用户名@域名或ip:/上传到的文件夹 修改nginx.conf文件 在server中添加以下几行代码（以下代码可与原来的配置http代码共存，所以无需删除之前http的配置）然后保存退出运行 nginx -s reload命令重启Nginx即可。 12345678910server &#123; listen 443 ssl; ssl on; ssl_certificate ssl/2020586_www.butong.live.pem; # 你解压开的文件放在的目录 ssl_certificate_key ssl/2020586_www.butong.live.key; # 你解压开的文件放在的目录 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; 、、、 # 后面的保持原来的配置文件不变即可 以上就是在阿里云环境下配置Nginx的ssl证书的完整过程。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>HTTPS协议</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error 与 exception的区别]]></title>
    <url>%2F2019%2F02%2F24%2Ferror-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Error与Exception的区别 同 1:两者都继承自Throwable 不同Exception 1: 可以是可被控制或不可控制(例如RuntimeException异常及其子类); 注:可控不可控就看在代码编写时能否检测到异常;2: 表示有一个程序员导致的错误;3: 应该在应用级被处理; Error 1: 总是不可控的（即在编译期不可探测到异常;2: 常用来表示系统错误;3: 应该在系统级被捕获;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
</search>
