<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android知识汇总“ hexo new Android知识汇总”</title>
      <link href="/2019/11/19/Android%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E2%80%9Chexo-new-Android%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E2%80%9D/"/>
      <url>/2019/11/19/Android%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E2%80%9Chexo-new-Android%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E2%80%9D/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>全称：Java Development Toolkit（Java语言开发工具包）。其中包含java虚拟机、java工具以及一些java基础类库。</p><h3 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h3><p>全程：Android Software Developmen Kit（安卓软件开发工具箱）。其提供了在windows/linux/mac平台开发安卓应用的开发组件，包含了在Android平台开发移动应用的各种工具集（例如：调试、打包等工具）</p><h3 id="HAXM"><a href="#HAXM" class="headerlink" title="HAXM"></a>HAXM</h3><p>intel的硬件加速执行管理器，利用intel的虚拟化技术加速Android开发的硬件辅助虚拟引擎。</p><h3 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h3><p>是一个项目构建工具，支持自动下载依赖包以及打包项目</p><a id="more"></a><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="项目结构目录"><a href="#项目结构目录" class="headerlink" title="项目结构目录"></a>项目结构目录</h3><table><thead><tr><th>文件</th><th>用户</th></tr></thead><tbody><tr><td>.gradle</td><td>Gradle编译系统</td></tr><tr><td>.idea</td><td>Android Studio IDE配置文件</td></tr><tr><td>app</td><td>应用源码核心文件夹</td></tr><tr><td>build</td><td>代码编译后生成的文件存放目录</td></tr><tr><td>gradle</td><td>wrapper的jar和配置文件在的地方</td></tr><tr><td>.gitinore</td><td>git的ignore配置文件</td></tr><tr><td>build.gradle</td><td>gradle编译的相关配置文件</td></tr><tr><td>gradle.propperties</td><td>gradle相关的全局属性配置</td></tr><tr><td>gradlew</td><td>gradle wrapper的可执行文件</td></tr><tr><td>gradlew.bat</td><td>windows下gradle wrapper的可执行文件</td></tr><tr><td>Hello World.iml</td><td>项目的配置文件</td></tr><tr><td>local.properties</td><td>本地属性配置（key设置，Android sdk位置等属性</td></tr><tr><td>settings.gradle</td><td>gradle的设置脚本</td></tr><tr><td>External.Librari</td><td>引用库</td></tr></tbody></table><h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><table><thead><tr><th>名称</th><th>功能</th></tr></thead><tbody><tr><td>aapt</td><td>产生R文件，以使资源文件能够在代码中引用</td></tr><tr><td>Navigation Editor</td><td>可视化管理Android 应用的结构和布局文件</td></tr><tr><td>adb</td><td>查询设备信息和数据库，安装程序到设备，端口映射以及移动文件等管理操作</td></tr><tr><td>Android 工具</td><td>创建和管理android virtual devices</td></tr><tr><td>Android层级阅览器</td><td>显示出各组件的布局及其联系</td></tr><tr><td>Draw Nine-patch</td><td>让开发设计能够拉伸的png图</td></tr><tr><td>DDMS（Dalvik Debug Monitor Service）</td><td>查看和管理运行在设备上的进程和线程、查看堆栈数据、连接到进程进行调试</td></tr><tr><td>Sqlite3</td><td>Android内置数据库</td></tr><tr><td>TraceView</td><td>将安卓程序产生的日志转化为图形化的分析师图</td></tr><tr><td>logcat</td><td>日志输出工具</td></tr></tbody></table><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h3><p>Linux内核（主要是一些驱动） —&gt; 系统运行库（媒体库、webkit、ssl等） —&gt; 应用程序框架（活动管理器、电话管理器、资源管理器等） —&gt; 应用程序（联系人、电话、浏览器等）</p><h3 id="应用程序编译原理和运行原理"><a href="#应用程序编译原理和运行原理" class="headerlink" title="应用程序编译原理和运行原理"></a>应用程序编译原理和运行原理</h3><blockquote><p>首先将资源编译为.java -&gt; 将.java编译为平台无关的.class -&gt; 将散乱的.class集合为虚拟机可加载可运行的.dex文件 -&gt; 将.dex与资源打包为未签名的apk -&gt; 将未签名的apk签名 -&gt; 将签名的apk优化</p></blockquote><ul><li>使用aapt工具将Application Resource编译为R.java和Compiled Resource。</li><li>使用aidl工具将.aidl文件编译为.java文件</li><li>使用javac将.java文件编译为.class文件</li><li>使用dx.bat文件将所有.class文件和第三方库集合成DVM可加载的.dex文件</li><li>apkbuilder将Compiled Resource、.dex以及其它的Resource打包成apk</li><li>使用jarsigned将打包的apk签名（签名需要Debug Keystore or Release Keystore)形成signed APK</li><li>使用zipalign优化打包的apk</li></ul><h3 id="activity四种加载模式"><a href="#activity四种加载模式" class="headerlink" title="activity四种加载模式"></a>activity四种加载模式</h3><ul><li>standard （默认）</li><li>singleTop</li><li>singleTask</li><li>singleInstance</li></ul><blockquote><p>下面我们用ABCDB的activity调用顺序模拟活动启动顺序</p></blockquote><h4 id="standard模式"><a href="#standard模式" class="headerlink" title="standard模式"></a>standard模式</h4><p><img src="https://user-images.githubusercontent.com/33340562/68528497-5e147780-032e-11ea-98a6-d9a522c5355c.png" alt="image"></p><p>最终：栈中有5个activity实例<br>解释：standard每次startActivity都会创建一个新的activity实例</p><h4 id="singleTop模式"><a href="#singleTop模式" class="headerlink" title="singleTop模式"></a>singleTop模式</h4><blockquote><p>example 1</p></blockquote><p><img src="https://user-images.githubusercontent.com/33340562/68528497-5e147780-032e-11ea-98a6-d9a522c5355c.png" alt="image"></p><blockquote><p>example 2<br>input: abcdd</p></blockquote><p><img src="https://user-images.githubusercontent.com/33340562/68528524-ea269f00-032e-11ea-937f-96ddd3abfe86.png" alt="image"></p><p>最终：栈中有4个activity实例<br>解释：singleTop当当前栈顶的activity是我们要启动的新activity时，直接使用栈顶的activity（调用其onNewIntent()），不会创建新的activity。</p><h4 id="singleTask模式"><a href="#singleTask模式" class="headerlink" title="singleTask模式"></a>singleTask模式</h4><p><img src="https://user-images.githubusercontent.com/33340562/68528571-82248880-032f-11ea-9cde-01e9d30c6037.png" alt="image"></p><p>最终：栈中有2个activity实例<br>解释：singleTask模式，如果栈中存在要启动的activity时，直接将该activity上的activity弹出，直到该activity位于栈顶。如果栈中不存在，则创建新的activity。</p><h4 id="singleInstance模式"><a href="#singleInstance模式" class="headerlink" title="singleInstance模式"></a>singleInstance模式</h4><blockquote><p>示例解释<br>FirstActivity、ThirdActivity是standard模式，SecondActivity是singleInstance模式<br>首先启动FirstActivity然后启动secondActivity，再启动ThirdActivity。然后按返回键</p></blockquote><p><img src="https://www.2cto.com/uploadfile/Collfiles/20161017/201610170925041558.png" alt="image"></p><p>最终：启动ThirdActivity后，总共有三个activity实例，两个任务栈。<br>解释：singleInstance模式时，会新建一个栈存放该activity。并且该栈只能存放该activity。所以在启动SecondActivity时，会将该activity放到返回栈B中。在启动ThirdActivity时，由于当前是显示SecondActivity，而栈B只能存放SecondActivity，所以启动ThirdActivity会重新回到栈A中。</p><h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><blockquote><p>service是一个可以在后台执行长时间运行操作而不提供用户界面的应用组件。<br>服务像Activity那样也是默认运行在主线程中，如果有耗时任务还是要在服务内部创建子线程，不然程序会GG。  </p></blockquote><h4 id="应用案例："><a href="#应用案例：" class="headerlink" title="应用案例："></a>应用案例：</h4><ul><li>用于处理网络事务（下载文件）</li><li>播放音乐（音乐播放器）</li><li>执行IO操作</li></ul><h4 id="服务的生命周期"><a href="#服务的生命周期" class="headerlink" title="服务的生命周期"></a>服务的生命周期</h4><blockquote><p>通过startService启动的服务  </p></blockquote><p>该服务需要在AndroidManifest.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyService"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>第一次调用startService(Intent)时： 执行onCreate() –&gt; onStartCommand() –&gt; service running  </li><li><p>第二次调用startService(Intent)时：执行onStartCommand() –&gt; service running</p></li><li><p>关闭可以调用activity中的stopService和service中的stopSelf：执行onDestory() –&gt; service shut down</p></li></ul><p>onCreate() –&gt; onStartCommand() –&gt; service running –&gt;onDestory() –&gt; service shut down</p><blockquote><p>通过bindService启动的服务</p></blockquote><ul><li>调用bindService时：执行onCreate() –&gt; onBind()(只会执行一次) –&gt; service running  </li><li>unbindService: activity退出时一定要调用unbindService，当所有</li></ul><p>onCreate() –&gt; onBind() –&gt; service running –&gt; onUnbind() –&gt; onDestory() –&gt; service shut down</p><p><img src="https://upload-images.jianshu.io/upload_images/3515789-fd974f027cb827be.png?imageMogr2/auto-orient/strip|imageView2/2/w/389/format/webp" alt="image"></p><h3 id="BroadCastReceiver"><a href="#BroadCastReceiver" class="headerlink" title="BroadCastReceiver"></a>BroadCastReceiver</h3><p>分类：常驻型广播、非常驻型广播</p><h4 id="非常驻型广播"><a href="#非常驻型广播" class="headerlink" title="非常驻型广播"></a>非常驻型广播</h4><blockquote><p>生命周期由开发者决定，通常在activity的onCreate方法中注册广播接收者，在onDestory中销毁广播。</p></blockquote><h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><blockquote><p>第一步：定义接收者</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"onReceiv"</span>, <span class="number">1</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>第二步：注册</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reigster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    NReceiver receiver = <span class="keyword">new</span> NReceiver();</span><br><span class="line">    <span class="comment">// 定义广播接收的消息</span></span><br><span class="line">    IntentFilter filter = <span class="keyword">new</span> IntentFilter(<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>);</span><br><span class="line">    registerReceiver(receiver,filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后：销毁广播</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    unregisterReceiver(receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常驻型广播"><a href="#常驻型广播" class="headerlink" title="常驻型广播"></a>常驻型广播</h4><blockquote><p>常驻型广播即使应用退出，也能接收到广播。</p></blockquote><h5 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h5><blockquote><p>第一步</p></blockquote><p>同上定义实现广播类</p><blockquote><p>第二步：在AndroidManifest中注册</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">".receiver.NReceiver"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:enabled</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.provider.Telephony.SMS_RECEIVED"</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Intent i = <span class="keyword">new</span> Intent(<span class="string">"com.hmkcode.android.USER_ACTION"</span>);</span><br><span class="line">sendBroadcast(i);</span><br></pre></td></tr></table></figure><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><blockquote><p>实现不同的应用程序之间共享数据</p></blockquote><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="activity"><a href="#activity" class="headerlink" title="activity"></a>activity</h3><blockquote><p>activity的四种状态：</p></blockquote><ul><li>Active/Running<br>activity处于屏幕的最前端，用户可以看到，并且与之交互。</li><li><p>Paused<br>用户依然能看到activity，但是用户不能与之交互。因为一个活动被另一个非全屏的活动覆盖住。例如：Dialog。处于这种状态的activity依然是活的，依然维护其相关信息，系统只会在内存极低的时候才将其回收。</p></li><li><p>Stop<br>已经完全不能看见该界面，但系统依然维持其相关内部状态。在手机内存被征用时，系统经常会将其回收。</p></li><li>Killed<br>activity已被系统回收或者还未启动</li></ul><p><img src="https://user-images.githubusercontent.com/33340562/68567727-b796b680-0494-11ea-8031-20c951fdcf6d.png" alt="image"></p><p><img src="https://i.bmp.ovh/imgs/2019/11/a0063a9cc387e9ac.png" alt></p><blockquote><p>其他两个回调函数</p></blockquote><ul><li>onSaveInstanceState()<br>Android系统在资源不足而终止activity之前调用，用以保存activity的 状态信息</li><li>onRestoreInstanceState()<br>恢复onSaveInstanceState保存的状态信息，在onStart与onResume之间使用。</li></ul><blockquote><p>两个activity跳转时，调用顺序：  </p></blockquote><p>系统将先后执行Activity1的onPause()–Activity2的onCreate()–<br>onStart()–onResume()–Activity1的onSaveInstance-State() –onStop()<br>系统在执行完Activity1的onPause()<br>之后，先将Activity2显示出来，再执行Activity1的onStop()操作，在执行完Activity1的onPause()后，<br>Activity1便不显示在屏幕的最前端了。</p><blockquote><p>由Activity1-&gt;Activity2-&gt;Back:  </p></blockquote><p>系统先后执行了Activity2的onPause()–Activity1的onRestart()–<br>onStart()–onResume()–Activity2的onStop()–onDestory()</p><h3 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a>fragment</h3><h4 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h4><p>在Android3.0之前版本，app通常是运行在小屏幕的设备上。随后为了支持大屏幕的平板电脑能够显示更多的信息，引进了fragment布局。一个activity中的不同fragment有各自的生命周期，因此能够专心处理各自的业务逻辑，而且共显示在一块屏幕上。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>Fragment是依赖于Activity存在的，所以生命周期与Activiy也有所相似。</p><blockquote><p>activity的onCreate对应Fragment:  </p></blockquote><p>onAttach() –&gt; onCreate() –&gt; onCreateView() –&gt; onActivityCreated()</p><blockquote><p>activity的onDestory()对应Fragment:  </p></blockquote><p>onDestoryView() –&gt; onDestory() –&gt; onDetach()</p><p><img src="https://i.bmp.ovh/imgs/2019/11/1209a69ea0d3651f.png" alt></p><h3 id="Intent属性"><a href="#Intent属性" class="headerlink" title="Intent属性"></a>Intent属性</h3><blockquote><p>Intent的Action（动作）  </p></blockquote><p>Action属性用于描述Intent要完成的动作</p><blockquote><p>Intent的Data（数据）  </p></blockquote><p>Data属性是执行动作的URI和MIME类型，可以传参</p><blockquote><p>Intent的Category（分类）</p></blockquote><p>Category属性指明一个执行Action的分类</p><table><thead><tr><th>Category属性</th><th>说明</th></tr></thead><tbody><tr><td>CATEGORY_DEFAULT</td><td>默认的执行方式，按照普通Activity的执行方式执行</td></tr><tr><td>CATEGORY_HOME</td><td>该组件为Home Activity</td></tr><tr><td>CATEGORY_LAUNCHER</td><td>优先级最高的Activity，通常为入口ACTION_MAIN配合使用</td></tr><tr><td>CATEGORY_BROWSABLE</td><td>可以使用浏览器启动</td></tr><tr><td>CATEGORY_GADGET</td><td>可以内嵌到另外的Activity中</td></tr></tbody></table><blockquote><p>Intent的Component（组件）  </p></blockquote><p>Component属性用于指明Intent目标组件的类名称。<br>通常Android会根据Intent中包含的其他属性的信息，进行查<br>找一个与之匹配的目标组件。但是，如果指定了Component这个属性，Intent则会<br>直接根据组件名查找到相应的组件。</p><p>使用时例如：intent.setClass(Activity1.this, Activity2.class)<br>这里就是指明了哪个组件</p><blockquote><p>Intent的Extra  </p></blockquote><p>Extra属性用于添加一些附加信息</p><h4 id="三种跳转方式"><a href="#三种跳转方式" class="headerlink" title="三种跳转方式"></a>三种跳转方式</h4><ul><li>不带参的跳转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(Activity1.<span class="keyword">this</span>, Activity2.class);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure><ul><li><p>带参的跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">"Name"</span>, <span class="string">"Kate"</span>);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">intent.setClass(Activity1.<span class="keyword">this</span>, Activity2.class);</span><br><span class="line">startActivity(intent);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取参数</span></span><br><span class="line"></span><br><span class="line">Bundle bundle = <span class="keyword">this</span>.getIntent().getExtras();</span><br><span class="line">String name = bundle.getString(<span class="string">"Name"</span>);</span><br></pre></td></tr></table></figure></li><li><p>带返回值的跳转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个页面</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setClass(Activity1.<span class="keyword">this</span>, Activity2.class);</span><br><span class="line"><span class="keyword">this</span>.startActivityForResult(intent, <span class="number">0</span>); <span class="comment">//第二个参数用于识别第二个页面传回来的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处接收返回的参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二个页面</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">bundle.putString(<span class="string">"Name"</span>, <span class="string">"Kate"</span>);</span><br><span class="line">intent.putExtras(bundle);</span><br><span class="line">intent.setClass(Activity2.<span class="keyword">this</span>, Activity1.class);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br><span class="line">finish();</span><br></pre></td></tr></table></figure></li></ul><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="控件与容器"><a href="#控件与容器" class="headerlink" title="控件与容器"></a>控件与容器</h3><ul><li>控件<br>eg: Button、TextView等，继承于View，其不能包含其他View</li><li>容器<br>eg: LinearLayout等，继承于ViewGroup，其能包含其他控件以及容器</li></ul><h3 id="给控件添加监听事件的四种方式"><a href="#给控件添加监听事件的四种方式" class="headerlink" title="给控件添加监听事件的四种方式"></a>给控件添加监听事件的四种方式</h3><ul><li><p>匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//响应事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>自定义事件监听类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">button.setOnClickListener(<span class="keyword">new</span> MyListener());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//响应事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Activity实现OnClickListener接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    button.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(v.getId()) &#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.btn:</span><br><span class="line">            <span class="comment">//响应事件</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在布局文件中添加onClick属性</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">"btnClick"</span> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">btnClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//响应事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h4><blockquote><p>LinearLayout  </p></blockquote><p>名称：线性布局<br>特点：组件垂直摆放、水平摆放<br>注意：当设置的方向放满后，再添加控件就在屏幕之外，无法看见  </p><blockquote><p>RelativeLayout  </p></blockquote><p>名称：相对布局<br>特点：利用控件之间的相对位置关系来布局<br>注意：只能与在兄弟组件和父组件进行相对布局  </p><blockquote><p>FrameLayout  </p></blockquote><p>名称：帧布局<br>特点：该容器中的控件没有上线左右关系，组件之间层叠放置<br>注意：容器中最后写的控件在容器的最顶层，使用android:bringToFront=”true|false”可将控件提到最顶层  </p><blockquote><p>TableLayout  </p></blockquote><p>名称：表格布局<br>特点：使用TableRow配合TableLayout，让TableLayout生成多个列  </p><blockquote><p>AbsoluteLayout  </p></blockquote><p>名称：绝对布局<br>特点：以屏幕左上角坐标为原点（0，0），控件位置以坐标的形式存在<br>确定：屏幕兼容性不好  </p><h3 id="资源文件夹"><a href="#资源文件夹" class="headerlink" title="资源文件夹"></a>资源文件夹</h3><table><thead><tr><th>目录</th><th>资源类型</th></tr></thead><tbody><tr><td>res/animator</td><td>存放property animation的xml文件(属性动画，作用于View的属性)</td></tr><tr><td>res/anim</td><td>存放补间动画或逐帧动画的xml文件(作用与View的视觉，不改变属性值)</td></tr><tr><td>res/raw</td><td>存放直接复制到设备中的任意文件，它们无需编译，添加到你的应用程序编译产生的压缩文件中。要使用这些文件，可以调用Resources.openRawResource(),参数是R.raw.somefilename</td></tr><tr><td>res/drawable</td><td>存放能转化为绘制文件的位图或者定义了绘制资源的XML文件</td></tr><tr><td>res/color</td><td>存放定义了颜色列表资源的XML文件</td></tr><tr><td>res/layout</td><td>存放定义了用户界面布局的XML文件</td></tr><tr><td>res/menu</td><td>存放定义了应用程序菜单资源的XML文件</td></tr><tr><td>res/values</td><td>存放定义了多种类型资源的XML文件(eg:字符串、数据、颜色、尺寸、样式)</td></tr><tr><td>res/xml</td><td>存放任意的xml文件，使用Resources.getXML()读取</td></tr></tbody></table><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p>service 的基本介绍，前面介绍过</p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><blockquote><p>发送广播的三种方法  </p></blockquote><ul><li>Context.sendBroadcast  </li><li>Context.sendOrderedBroadcast  </li><li>Context.sendStickyBroadcast  </li></ul><blockquote><p>区别  </p></blockquote><ul><li><p>sendBroadcast或sendStickyBroadcast发送出去的Intent，对于所有满足条件的BroadcastReceiver都会执行其onReceive方法，但是多个BroadcastReceiver的onReceive的执行顺序无法保证。  </p></li><li><p>sendOrderedBroadcastReceiver发出去的Intent，会根据注册时IntentFilter设计的优先级执行onReceive方法，但是同优先级的BroadcastReceive执行顺序无法保证。</p></li><li><p>sendStickyBroadcast主要特点是，Intent发送后会一直存在，并在以后注册相的Receiver时，会直接将这个Intent返回给刚注册的Receiver。</p></li></ul><h3 id="发送广播-1"><a href="#发送广播-1" class="headerlink" title="发送广播"></a>发送广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String Intent_Action = com.android.BroadcastReceiverDemo;</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent_Action);</span><br><span class="line">Intent.putExtra(<span class="string">"参数"</span>，<span class="string">"参数值"</span>)；</span><br><span class="line">SendBroadcast(intent)；</span><br></pre></td></tr></table></figure><h3 id="接收广播"><a href="#接收广播" class="headerlink" title="接收广播"></a>接收广播</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//onReceive()方法必须5秒内执行完事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    String Itent_Action = com.android.BroadcastReceiverDemo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(intent.getAction().equals(Intent_Action)) &#123;</span><br><span class="line">            <span class="comment">//相应的处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h3><blockquote><p>代码注册广播 </p></blockquote><p>非常驻型广播：广播生命周期由程序决定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyBroadcastReceiver receiver = <span class="keyword">new</span> MyBroadcastReceiver();</span><br><span class="line"><span class="comment">//实例化过滤器并设置要过滤的广播</span></span><br><span class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(<span class="string">"Intent_Action"</span>);</span><br><span class="line"><span class="comment">//注册广播</span></span><br><span class="line">registerReceiver(receiver，intentFilter);</span><br></pre></td></tr></table></figure><blockquote><p>AndroidManifext.xml中注册广播  </p></blockquote><p>常驻型广播：程序关闭后，有信息广播过来，程序也会调用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span> = <span class="string">"MyBroadcastReceiver"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span> = <span class="string">" com.androidbook.MyBroadcastReceiver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="广播其他分类"><a href="#广播其他分类" class="headerlink" title="广播其他分类"></a>广播其他分类</h3><blockquote><p>广播又分为有序广播和正常广播  </p></blockquote><p>有序广播的优先级范围 -1024 至 1024。数字越大，优先级越大。动态注册的广播优先级总是高于静态注册的广播</p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p>安卓的四种数据存储：SharedPreference、SQLite、File和ContentProvider。</p><ul><li><p>SharedPreference：一种常用的数据存储方式，其本质是基于XML文件存储键值对，通常用来存储一些简单的配置信息。</p></li><li><p>SQLite：一个轻量级数据库，执行SQL语句。</p></li><li><p>文件存储：常用于存储数据量比较大的文件，缺点是更新数据困难。</p></li><li><p>ContentProvider：用于安卓系统中应用程序之间数据共享的一种方式。</p></li></ul><h3 id="SharedPreference"><a href="#SharedPreference" class="headerlink" title="SharedPreference"></a>SharedPreference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SharedPreferences sharedPreferences = getSharedPreferences(<span class="string">"type"</span>,</span><br><span class="line">Context.MODE_APPEND);</span><br><span class="line">Editor editor = sharedPreferences.edit();</span><br><span class="line"><span class="comment">// String字符串型</span></span><br><span class="line">editor.putString(<span class="string">"String"</span>, <span class="string">"words"</span>);</span><br><span class="line"><span class="comment">// Boolean布尔型</span></span><br><span class="line">editor.putBoolean(<span class="string">"Boolean"</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// Integer整型</span></span><br><span class="line">editor.putInt(<span class="string">"Integer"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// Long长整型</span></span><br><span class="line">editor.putLong(<span class="string">"Long"</span>, <span class="number">1000000</span>);</span><br><span class="line"><span class="comment">// Float浮点数型</span></span><br><span class="line">editor.putFloat(<span class="string">"Float"</span>, <span class="number">3.5f</span>);</span><br><span class="line">editor.commit();</span><br></pre></td></tr></table></figure><h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li><p>也不支持一些标准的SQL功能，特别是外键约束（FOREIGNKEY constrains），嵌套<br>transcaction和RIGHTOUTERJOIN和FULLOUTERJOIN，迓有一些ALTERTABLE功能。  </p></li><li><p>和其他数据库最大的丌同就是对数据类型的支持</p></li></ul><p>存储类型:  </p><table><thead><tr><th>存储类</th><th>描述</th></tr></thead><tbody><tr><td>NULL</td><td>值是一个NULL值</td></tr><tr><td>INTEGER</td><td>值是一个带符合的整数，根据值的大小存在1、2、3、4、6或8字节中。</td></tr><tr><td>REAL</td><td>值是一个浮点值，存储为8字节的IEEE浮点数字。</td></tr><tr><td>TEXT</td><td>值是一个文本字符串，使用数据库编码存储。</td></tr><tr><td>BLOB</td><td>值是一个blob数据，完全根据它的输入存储。</td></tr></tbody></table><h4 id="亲和类型"><a href="#亲和类型" class="headerlink" title="亲和类型"></a>亲和类型</h4><p>亲和类型：TEXT、NUMERIC、REAL、INTEGER、NONE<br>作用: 为了和其他DBMS以及SQL兼容，在create table中指定列类型时，SQLite会根据字段声明的类型，为其选择一种亲缘类型。  </p><p>创建的数据库文件位于/data- /data/\<package name>/databases/&lt;数据库名&gt;.db  </package></p><h3 id="ContentProvider-1"><a href="#ContentProvider-1" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p>作用： ContentProvider是Android平台中，在丌同应用程序乊间实现数据共享的唯一机制。  </p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><h3 id="socket与http的区别"><a href="#socket与http的区别" class="headerlink" title="socket与http的区别"></a>socket与http的区别</h3><ul><li>socket不是协议是一个接口，http是一个协议</li><li>http对应于应用层，socket是对TCP/IP协议的封装，对应于传输层  </li><li>http是短连接、socket是长连接</li></ul><h3 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h3><blockquote><p>用以表示服务器http响应状态</p></blockquote><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>100</td><td>客户端应当继续发送请求</td></tr></tbody></table><p>| 200 | 成功 |<br>| 300 | 重定向 |<br>| 400 | 请求错误 |<br>| 403 | 拒绝访问 |<br>| 404 | 找不到资源 |<br>| 500 | 服务器错误 |</p><h3 id="socket三次握手"><a href="#socket三次握手" class="headerlink" title="socket三次握手"></a>socket三次握手</h3><p>确保双方都能成功连接到彼此</p><p>第一次握手：判断A到B方向是否通的<br>第二次握手：确定A到B方向是通的，并开始判断B到A方向是否连通<br>第三次握手：确定B到A方向是连通的  </p><h3 id="socket四次挥手"><a href="#socket四次挥手" class="headerlink" title="socket四次挥手"></a>socket四次挥手</h3><p>保证断开连接时，传输数据的完整性  </p><p>第一次挥手：A告诉B断开<br>第二次挥手：B告诉A收到断开请求，但是可能数据还没传输完，所以等待数据传输完，所以告诉A等下。<br>第三次挥手：B告诉A，可以断开了<br>第四次挥手：A告诉B，好的  </p><h3 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h3><p>全称：Simple API for XML。既是一种接口，也是一种软件包.它是xml解析的替代方式。</p><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ul><li>根本区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位。  </li><li>进程之间的切换有很大消耗，而线程之间的切换开销小。  </li><li>操作系统包括多个进程，而一个进程包含多个线程。  </li></ul><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元。  </p><p>进程间的通信：使用Binder实现  </p><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><p>定义：线程是进程中的一个实体，将程序的执行和资源分开，一个进程可拥有多个线程。</p><h3 id="Android的线程模型"><a href="#Android的线程模型" class="headerlink" title="Android的线程模型"></a>Android的线程模型</h3><h4 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h4><p>一个进程中只能有一个线程在运行，剩下的线程必须等待当前的线程执行完再执行。</p><h4 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h4><p>当多个线程访问一个类时，如果不考虑这些线程运行时的调度和交替执行，并且不需要额外的同步，这个类的行为仍然是正确的。那么称这个类是线程安全的。</p><h3 id="Handler的基本概念"><a href="#Handler的基本概念" class="headerlink" title="Handler的基本概念"></a>Handler的基本概念</h3><p>定义：Handler类是Android系统为开发者封装的一个能异步处理消息的辅助类。</p><h4 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h4><ul><li><p>得到Looper对象，得到MessageQueue对象（Looper.prepare()方法内部完成这两件事）。</p></li><li><p>实例化Handler并复写handleMessage()方法，用来接收传递过来的消息，并作相应处理。</p></li><li><p>调用loop()方法死循环获得消息队列的变化，并分发消息，最终回调HandleMessage()。</p></li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li><p>在activity启动的过程中，主线程已经调用了Looper.prepare()和Looper.loop()方法，所以我们只需要实例化Handler。</p></li><li><p>在UI线程使用Handler h = new Handler();时，系统默认将Looper的对象和MessageQueue关联到UI线程。若加入非UI线程，系统不会调用Looper的prepare()方法</p></li></ul><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><table><thead><tr><th>核心方法</th><th>作用</th><th>调用时刻</th><th>备注</th></tr></thead><tbody><tr><td>execute(Params …params)</td><td>触发执行异步线程任务</td><td>手动调用</td><td>必须运行在主线程</td></tr><tr><td>onPreExecute()</td><td>执行线程任务前的操作(根据需求重写)</td><td>执行execute前自动调用</td><td>用于界面的初始化</td></tr><tr><td>doInBackground(Params …params)</td><td>执行任务（必须重写）</td><td>执行onPreExecute后自动调用</td><td>不能更改UI，可调用publishProgress()更新UI</td></tr><tr><td>onProgressUpdate(Progress value)</td><td>在主线程中更新任务执行的进度</td><td>调用publishProgress()后，自动调用</td><td>–</td></tr><tr><td>onPostExecute(Result result)</td><td>接收线程任务执行结果、将执行结果更新到UI组件</td><td>线程任务结束时自动调用</td><td>–</td></tr><tr><td>onCancelled()</td><td>将异步任务设置为取消状态</td><td>异步任务被取消时自动调用</td><td>该方法被调用后，onPostExecute就不会被调用</td></tr></tbody></table><h2 id="第十二章"><a href="#第十二章" class="headerlink" title="第十二章"></a>第十二章</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>概念：<br>任何计算机系统都包含一个基本的程序集合  </li><li>目的：<br>与硬件交互，管理所有的硬件资源<br>为用户程序提供一个良好的执行环境  </li></ul><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><ul><li>作用：<br>1：传递参数<br>2：保存函数调用时的上下文  </li></ul><p>堆栈：存放函数的参数值，局部变量的值等<br>常量区：字符串常量和其他常量的存储位置</p><h3 id="用户态与内核态"><a href="#用户态与内核态" class="headerlink" title="用户态与内核态"></a>用户态与内核态</h3><p>区分用户态和内核态：  </p><ul><li>禁止用户程序和底层硬件直接打交道</li><li>禁止用户程序访问任意的物理内存</li></ul><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><ul><li>中断：异步的，由硬件随机产生，在程序执行的任何时刻都有可能产生中断。</li><li>异常：同步的，在指令执行时由CPU控制单元产生。</li></ul><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><ul><li>操作系统为用户态进程与硬件设备进行交互提供了一组接口</li></ul><h2 id="第十三章"><a href="#第十三章" class="headerlink" title="第十三章"></a>第十三章</h2><ul><li><p>GNU：一个类似 Unix ,且为 自由软件 的完整的操作系统。其使用Linux内核</p></li><li><p>GCC：GNU Compiler Collection，符合ISO等标准的C编译器</p></li><li><p>Make：是一种代码维护工具，在使用GNU编译器开发大型应用时，往往要使用make管理项<br>目。</p></li><li><p>makefile：Makefile告诉make该做什么、怎么做</p></li></ul><h2 id="第十四章"><a href="#第十四章" class="headerlink" title="第十四章"></a>第十四章</h2><h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><p>X86复位后工作在实模式下，该模式下CPU的寻址空间为1M。<br>CPU复位（reset）或加电（power on）的时候就是以实模式启动。<br>在实模式下，不能访问20位以上的地址线，也就是只能访问1M内存。所以用于加载操作系统，然后进入保护模式。</p><h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>实模式下，程序员指定的地址就是物理地址。这样会带来程序的安全性问题。所以为了避免这个问题，提出了保护模式。保护进程地址空间。</p><h3 id="Android的启动过程"><a href="#Android的启动过程" class="headerlink" title="Android的启动过程"></a>Android的启动过程</h3><ul><li>Loader层进行Boot ROM 和 Boot Loader。</li><li>内核层创建0号进程：idle(swapper)，运行在内核中，是唯一一个没有通过fork和kernel_thread产生的进程。常常称为交换进程。</li><li>Native层创建init进程(1号进程)，而init进程是由idle通过kernel_thread创建的。它是系统中所有其他用户进程的祖先进程。Linux中所有的进程都是由init进程创建并运行的。在系统启动完后，init变为守护进程监视系统的其他进程。</li><li>然后创建受精卵进程<br><img src="https://user-images.githubusercontent.com/33340562/69007131-c093f600-0974-11ea-9482-e98259f249d7.png" alt="image"></li></ul><h2 id="第十五章"><a href="#第十五章" class="headerlink" title="第十五章"></a>第十五章</h2><p>进程</p><h3 id="进程描述符"><a href="#进程描述符" class="headerlink" title="进程描述符"></a>进程描述符</h3><p>使用进程描述符地址标识一个进程，每个进程的Process ID(PID)都放在进程描述符的pid域中。</p><h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><p>do_fork -&gt; copy_process -&gt; alloc_pid</p><ul><li>fork 是 创建一个子进程，并把父进程的内存数据copy到子进程中。</li><li>vfork是 创建一个子进程，并和父进程的内存数据share一起用。</li></ul><h4 id="内核线程与普通进程的差别"><a href="#内核线程与普通进程的差别" class="headerlink" title="内核线程与普通进程的差别"></a>内核线程与普通进程的差别</h4><ul><li>每个内核线程执行一个单独指定的内核函数</li><li>只运行在内核态</li><li>只使用大于PAGE_OFFSET的线性地址空间</li></ul><h4 id="进程0"><a href="#进程0" class="headerlink" title="进程0"></a>进程0</h4><p>所有进程的祖先叫做进程0  </p><p>在系统初始化阶段由start_kernel()函数从无到有手工创建<br>的一个内核线程<br> Init_task<br> Init_thread_union<br> 进程0最后的初始化工作创建init内核线程，此后运行cpu_idle，<br>成为idle进程  </p><h4 id="进程1"><a href="#进程1" class="headerlink" title="进程1"></a>进程1</h4><p>又称为init进程<br>由进程0在start_kernel调用rest_init创建<br>init进程PID为1，当调度程序选择到init进程时，<br>init进程开始执行kernel_init ()函数</p><h4 id="课堂测试"><a href="#课堂测试" class="headerlink" title="课堂测试"></a>课堂测试</h4><p>fork返回值为0，则当前进程为子进程<br>fork返回值非0，则当前进程为父进程，且返回的值为子进程的pid  </p><blockquote><p>调用fork创建一个子进程，然后让子进程和父进程分别输出<br>fork的返回值  </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = fork();</span><br><span class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"error in fork!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//fork出错退出</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"子进程返回%d"</span>, i);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pprintf(<span class="string">"父进程返回%d"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>连续3次调用fork， 然后让子进程和父进程分别输出fork的<br>返回值和各自的pid，说明一共创建了几个进程？画出进程<br>之间的创建关系（进程使用pid来标识）</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> pid1 = <span class="number">0</span>, pid2 = <span class="number">0</span>, pid3 = <span class="number">0</span>;</span><br><span class="line">pid1 = fork();</span><br><span class="line">pid2 = fork();</span><br><span class="line">pid3 = fork();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fork 返回值 pid1=%d，current process pid = %d"</span>, pid1, getPid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fork 返回值 pid2=%d，current process pid = %d"</span>, pid2, getPid());</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"fork 返回值 pid3=%d，current process pid = %d"</span>, pid3, getPid());</span><br></pre></td></tr></table></figure><p>总共创建7个进程</p><h2 id="第十七章"><a href="#第十七章" class="headerlink" title="第十七章"></a>第十七章</h2><h3 id="NUMA"><a href="#NUMA" class="headerlink" title="NUMA"></a>NUMA</h3><p>名称：非统一内存访问架构<br>作用：物理内存划分为若干个node  </p><h3 id="存储区"><a href="#存储区" class="headerlink" title="存储区"></a>存储区</h3><p>作用：为了解决页框由于自身物理地址的原因，不能被一些任务所使用的限制。Linux将物理内存划分为区。</p><p>Linux将物理存储器分为4个区：<br>ZONE_DMA<br>ZONE_DMA32(未使用)<br>ZONE_NORMAL<br>ZONE_HIGHMEN</p><p>ZONE_DMA和ZONE_NORMAL区：包含存储器的常规页，通过把它们映射到线性地址空间的3GB以上，内核就可以直接访问了。<br>ZONE_HIGHMEN区不能直接由内核访问。  </p><h3 id="外部碎片"><a href="#外部碎片" class="headerlink" title="外部碎片"></a>外部碎片</h3><p>导致原因：频繁的请求和释放不同大小的一组连续页框，导致物理页框中分散许多小的空闲页框。  </p><p>解决方法：</p><ul><li>利用MMU（内存管理单元）把一组非连续的物理空闲空间映射到连续的线性地址空间。</li><li>用一种技术记录空闲连续页框的情况，以避免满足对小块的满足而将大块空闲块进行切割。</li></ul><h3 id="伙伴算法"><a href="#伙伴算法" class="headerlink" title="伙伴算法"></a>伙伴算法</h3><p>解决外部碎片  </p><p>➢ 把所有空闲页框分组为10（Linux2.6.26为11）个块链<br>表，每个块链表分别包含大小为1，2，4，8，16，32<br>，64，128，256和512个连续的页框<br>➢ 每个块的第一个页框的物理地址是该块大小的整数倍<br>⚫例如：大小为16个页框的块，其起址是16×4KB的倍数</p><p>伙伴算法对逻辑地址空间的页框进行管理，找到页框后，通过mem_map数组映射到页框对应的物理地址。</p><h3 id="slab"><a href="#slab" class="headerlink" title="slab"></a>slab</h3><p>作用：内存分配机制，解决内部碎片  </p><p>Slab 相当于内存池思想，且是为了解决内碎片而产生的，slab的核心思想是<br>以对象的观点管理内存。</p><h3 id="缺页异常"><a href="#缺页异常" class="headerlink" title="缺页异常"></a>缺页异常</h3><p>内核只是通过mmap()调用  分配了一些线性地址空间给进程，并没有把实际的物理页框分配给进程。当通过线性地址空间区访问物理页框，而并没有物理页框对应这些线性地址空间时，就会引发缺页异常。</p><p>中断：中断是指来自CPU执行指令以外的事件发生后，处理机暂停正在运行的程序，转去执行处理该事件的程序的过程。  </p><p>异常：异常是指源自CPU执行指令内部的事件发生后，处理机暂停正在运行的程序，转去执行该事件的过程。  </p><h4 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h4><p>中断上下文不同于进程上下文<br>中断或异常处理程序执行的代码不是一个进程<br>它是一个内核控制路径，代表了中断发生时正在执行的代码。</p><p>中断分类：</p><ul><li>可屏蔽中断</li><li>非屏蔽中断<br>只有几个特定的危急事件才引起非屏蔽中断。如硬件故障或者掉电</li></ul><p>异常分类：</p><ul><li>处理器探测异常<br>如：溢出、除0错</li><li>编程异常<br>由编程者发出，通常称为‘软中断’。例如：系统调用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AtomicXXX源码（一）</title>
      <link href="/2019/10/19/AtomicXXX%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/10/19/AtomicXXX%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇将会介绍<code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>这三个原子类</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>这三个类是为了实现其对应类线程安全的一些操作。例如i++问题，这行代码包括三个步骤：读取i，将值+1，写入i。在执行这三个步骤的过程中，i都有可能被其他线程修改。那最终将会导致i的值出错。我们将这种问题称为<code>状态依赖</code>。<br>状态依赖：变量下一个值依赖于前一个值，例如i = 5, i++; 最后i是多少，依赖于i初始值，这里i = 5,所以最终i = 6。  </p><h2 id="解决i-线程不安全问题"><a href="#解决i-线程不安全问题" class="headerlink" title="解决i++线程不安全问题"></a>解决i++线程不安全问题</h2><p>AtomicInteger等三个类，为了解决i++类似的线程不安全问题，有两个核心点，一个是使用volatile保证值的可见性，另一个是CAS无锁式同步机制。其中CAS全称Compare and Swap（先比较再替换）。</p><a id="more"></a><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>如果不清楚类的初始化顺序，请跳转☞。<br>这三个类源码基本都是一样的，所以我把这三个类放一起记录。根据类的初始化顺序我们先看静态代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码，AntomicInteger中有个value变量，该变量使用<code>volatile</code>修饰。    </p><blockquote><p>为什么会用这个修饰呢？  </p></blockquote><p>对于volatile大家都很熟悉，它能够保证变量的可见性，也就是当一个线程对变量a做出改变时，另一个变量能够立马发现变量a的变化。而我们AtomicInteger使用CAS需要<code>比较然后替换</code>，如果是跟一个旧值比较，那有何意义（这是一个需要大家思考的问题）。</p><p>然后代码块中会调用<code>unsafe.objectFieldOffset</code>方法，这个方法就是获取某个属性在类中的偏移地址。获取到这个偏移地址后，我们就可以根据内存地址直接修改其内存中的值了。   </p><blockquote><p>对于静态代码块执行之后的构造方法我就不做过多的解释了，因为其构造函数没什么有意义的东西。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new AtomicInteger with the given initial value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> initialValue the initial value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">(<span class="keyword">int</span> initialValue)</span> </span>&#123;</span><br><span class="line">    value = initialValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new AtomicInteger with initial value &#123;<span class="doctag">@code</span> 0&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AtomicInteger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法分析"><a href="#方法分析" class="headerlink" title="方法分析"></a>方法分析</h3><blockquote><p>常用的getAndIncrement方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UnSafe类中的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * var1: AtomicInteger对象的地址</span></span><br><span class="line"><span class="comment"> * var2: 对象中int值的偏移地址</span></span><br><span class="line"><span class="comment"> * var4: AtomicInteger中int变量的变化量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是一种典型的CAS自旋锁，所谓的自旋锁就是在别人修改的时候，自己一直循环访问是否能修改值，而不会被阻塞直到资源占用着释放资源才被唤醒。在上面的代码中，UnSafe的<code>compareAndSwapInt</code>是调用了C语言的原生代码。在compareAndSwapInt中，会进行比较。如果内存中的值跟预期的var5一样，则返回true，否则返回false直到内存中的值与预期的var5一样，才将var5 + var4写入内存中。  </p><blockquote><p>疑问</p></blockquote><p>如果内存中的值与我们预期的var5一样，然后开始准备写入我们的var5 + var4时，内存中的值被人修改了怎么办？会发生这种情况吗？（这句话的意思能体会吗）</p><p><img src="https://i.loli.net/2019/10/18/d7SN5WhF21jYVtU.png" alt="image.png"></p><p>如果会发送图中的情况，那么AtomicInteger将不是线程安全的类。经过查找网上大家都说<code>比较并替换</code>是由硬件完成的，而这个操作是不会响应中断，所以保证了它的原子性。</p><blockquote><p>IntUnaryOperator类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment"> * applying the given function, returning the previous value. The</span></span><br><span class="line"><span class="comment"> * function should be side-effect-free, since it may be re-applied</span></span><br><span class="line"><span class="comment"> * when attempted updates fail due to contention among threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> updateFunction a side-effect-free function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在AtomicInteger类中，只是定义了getAndIncrement和getAndDecrement等简单的操作。但是还有很多复杂的并且依赖之前的值的操作，比如value = value / 2等等，不可能全部实现在类中。所以AtomicInteger提供了一些<code>函数接口</code>，例如<code>IntUnaryOperator</code>用户实现该接口，并且在其中进行一些复杂的操作来完成需求。</p><blockquote><p>简单的使用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntUnaryOperatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger num = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">        System.out.println(num.getAndUpdate(<span class="keyword">new</span> Operator()));</span><br><span class="line">        System.out.println(num.getAndUpdate(v -&gt; v * <span class="number">100</span>)); <span class="comment">// lambda表达式写法， java8中的函数接口都可以用lambda表达式</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span> <span class="keyword">implements</span> <span class="title">IntUnaryOperator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">applyAsInt</span><span class="params">(<span class="keyword">int</span> operand)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello----------------applyAsInt"</span>);</span><br><span class="line">        <span class="keyword">return</span> operand + <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>compareAndSet和weakCompareAndSet</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful. False return indicates that</span></span><br><span class="line"><span class="comment"> * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically sets the value to the given updated value</span></span><br><span class="line"><span class="comment"> * if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;&lt;a href="package-summary.html#weakCompareAndSet"&gt;May fail</span></span><br><span class="line"><span class="comment"> * spuriously and does not provide ordering guarantees&lt;/a&gt;, so is</span></span><br><span class="line"><span class="comment"> * only rarely an appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在weakCompareAndSet注释中说，weakCompareAndSet不保证指令不会重排序，而且可能会替换失败。但是其调用的代码与compareAndSet一模一样，所以我猜测这个在功能上与compareAndSet，并未实现像其注释说的一样。</p>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>concurrent包源码阅读开篇</title>
      <link href="/2019/10/16/concurrent%E5%8C%85%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/"/>
      <url>/2019/10/16/concurrent%E5%8C%85%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间认识了一个从事深度学习方向的博士学长，这个学长帮导师写一个项目临时要用java做开发。学长由于不太会java就问了我一个并发框架的问题，可是我这个声称是学java的却回答不上来。顿时觉得有种没学过java的感觉，为了以后不会发生这种尴尬，遂决心阅读concurrent包中的源码，并以此系列作为笔记。</p><h2 id="并发面临的问题"><a href="#并发面临的问题" class="headerlink" title="并发面临的问题"></a>并发面临的问题</h2><p>并发中常遇见的问题有原子性问题、可见性问题。其中由于jvm对代码的优化还带来了有序性问题。</p><a id="more"></a><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>现代电脑处理器基本有多个内核，而每个内核上可以跑一个线程，所以电脑可以实现真正的并行运算。而两个并行运算的线程难免有所交集处理了一个变量。就如下面的情况，这样线程A得到的值最后竟然是0。有时候出现这种情况是致命性的，所以为了避免这种情况发送我们要确保对变量a进行处理和赋值的过程是原子性的，不能被中断。</p><p><img src="https://user-images.githubusercontent.com/33340562/66917186-7f47b800-f04f-11e9-936e-f5c7291c781e.PNG" alt="捕获"></p><p>在java中如果要实现原子性可以对操作进行加锁，例如使用<code>synchronized</code>和<code>Lock</code>。同过这些锁，可以使一个代码块或者对象只能被一个线程使用，其他线程只能等使用者用完。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>在java的线程内存模型中，线程会共享本进程分配得到的内存。而每个线程会有属于自己的工作内存（工作内存线程之间不共享），他们会把一些共享变量拷贝到自己的工作内存。对共享变量进行操作时，会首先对自己工作内存进行操作，所以线程a<code>看不到</code>线程b对共享变量的操作，除非将线程b的工作内存刷新到主内存中，线程a才能看到（什么时候刷新我不太清楚，知道的大佬可以教教我）。</p><p><img src="https://user-images.githubusercontent.com/33340562/66920422-d3ee3180-f055-11e9-800e-4cf2a8ffee1d.png" alt="image"></p><p>正是因为线程a可能看不到线程b对变量的改变，就产生了变量的可见性问题。<br>例如可以执行如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(flag) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">"中的循环结束了"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"检测Flag的线程"</span>).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag的值为"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解决共享变量的可见性问题就是使用volatile。具体详情可以参考<a href="https://www.cnblogs.com/monkeysayhi/p/7654460.html" target="_blank" rel="noopener">https://www.cnblogs.com/monkeysayhi/p/7654460.html</a><br>可以将class文件反编译成汇编语言进行验证。</p><blockquote><p>下期，将会写读并发包源码的笔记</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 并发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 源码 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2019/09/24/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/24/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>假设系统中存在一个对象A被频繁的创建。如果某一天，需求发生变化，我们要重新改变对象A的创建的时候，发现A在几十个甚至上百个java文件中创建了。我们该怎么办？一个一个修改吗？</p></blockquote><p>当我们遇见这种经常使用的对象时，就该想想是否是要用到工厂模式了。为了少加班做无用功，让我们看看工厂模式是怎么解决这种问题的。<br><a id="more"></a></p><hr><h2 id="假设背景"><a href="#假设背景" class="headerlink" title="假设背景"></a>假设背景</h2><p>假设我们刚开始时建一个只有高度和宽度的手机类。<br>然后创建N个手机类对象。<br>突然，产品锦鲤要我们给手机类加上颜色属性。</p><h2 id="未用工厂模式"><a href="#未用工厂模式" class="headerlink" title="未用工厂模式"></a>未用工厂模式</h2><p>刚开始建的手机类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未上色的手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Phone&#123;"</span> +</span><br><span class="line">                <span class="string">"width="</span> + width +</span><br><span class="line">                <span class="string">", height="</span> + height +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>手机类建好了，我们开始生产手机把</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone1 = <span class="keyword">new</span> Phone(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">        Phone phone2 = <span class="keyword">new</span> Phone(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">        Phone phone3 = <span class="keyword">new</span> Phone(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">        Phone phone4 = <span class="keyword">new</span> Phone(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">        Phone phone6 = <span class="keyword">new</span> Phone(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">        Phone phone7 = <span class="keyword">new</span> Phone(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">        Phone phone8 = <span class="keyword">new</span> Phone(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生产了一批没上色的手机，这个时候，产品锦鲤要求手机要加个颜色属性，并且构建的时候就要初始化。加吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上色的手机类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Phone</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, String color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Phone&#123;"</span> +</span><br><span class="line">                <span class="string">"width="</span> + width +</span><br><span class="line">                <span class="string">", height="</span> + height +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可是回头看Main方法（生产手机的地方）</p><p><img src="https://user-images.githubusercontent.com/33340562/65507845-64c36880-df01-11e9-876b-1cc2d07fa862.png" alt="image"></p><p>发现使用之前构造手机的方法不行了，我们要把它们一个一个加上颜色。在这里我们还只是用了8次而且都在一个文件中。如果真的在开发环境中，一个类用了几十次，并且都分布在不同的文件中，突然发现要给类加东西怎么办？</p><p>所以在项目中发现存在这种对象存在，就要考虑是否要用工厂模式来生产该对象了。下面我们看看使用简单工厂模式。</p><hr><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>我们先用只有高度和宽度属性的手机类，然后在简单工厂模式创建手机类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Phone(<span class="number">10</span>, <span class="number">15</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在主方法中使用PhoneFactory创建Phone对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = PhoneFactory.createPhone();</span><br><span class="line">        Phone phone1 = PhoneFactory.createPhone();</span><br><span class="line">        Phone phone2 = PhoneFactory.createPhone();</span><br><span class="line">        Phone phone3 = PhoneFactory.createPhone();</span><br><span class="line">        Phone phone4 = PhoneFactory.createPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们给Phone类加上颜色属性。<br>这个时候我们发现PhoneFactory中创建Phone报错，但是主方法中由于未直接使用Phone的构造方法，所以当Phone的构造方法发生改变时，主方法也不会报错。这样整个项目就只有PhoneFactory一处报错，我们就很容易修改。</p><p><img src="https://user-images.githubusercontent.com/33340562/65508361-a0aafd80-df02-11e9-9763-e2e423b9ab76.png" alt="image"></p><p>修改如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Phone(<span class="number">10</span>, <span class="number">15</span>, <span class="string">"黑色"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>问题</p></blockquote><p>但是使用简单工厂模式有几个缺点：</p><ul><li>不符合<strong>开闭原则</strong>。</li></ul><p>当我们需要添加新的类由工厂创建的时候，我们需要修改原来的PhoneFactory类。</p><ul><li>臃肿</li></ul><p>当PhoneFactory类中加入了大量的创建对象方法后，PhoneFactory会变得及其臃肿。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象方法模式</title>
      <link href="/2019/09/24/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/09/24/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>现实生活中，许多事务的处理步骤是固定的，但是每步详细的处理方法可能不尽相同。  </p></blockquote><p>例如：我们在外面回家时就要经历两个步骤。</p><ul><li>第一步：买车票</li><li>第二步：坐车</li></ul><p>假如我们不使用抽象方法模式写一个乘坐火车（Train）和乘坐大巴（bu）回家的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坐大巴回家</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoHomeByBus</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去汽车站买汽车票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sitCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去汽车站坐车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buyTicket();</span><br><span class="line">        sitCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坐火车回家</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoHomeByTrain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去火车站买火车票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sitCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去火车站坐车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goHome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buyTicket();</span><br><span class="line">        sitCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>冗余问题</p></blockquote><p>会发现我们在两种回家的类中都写了<code>goHome</code>方法，而且由于回家的流程一样，所以该方法的内容都一样，如果还需要添加其他的回家方式，就会造成了更多冗余。</p><blockquote><p>解决冗余</p></blockquote><p>所以我们可以提取一个GoHome类，将goHome方法写在GoHome类中，然后让描述不同回家方式的类继承GoHome，那么就很好解决了冗余的问题。</p><p>因为我们要将goHome方法写在GoHome类中，而goHome调用的方法在GoHome类中不存在，所以我们也要将其调用的方法上升到GoHome类中。而这几个方法是与回家方式相关的，所以将它们声明为abstract方法，让子类去实现。</p><blockquote><p>UML图</p></blockquote><p><img src="https://user-images.githubusercontent.com/33340562/65492160-06878d00-dee3-11e9-8ff1-481eb29ee860.png" alt="image"></p><blockquote><p>具体代码</p></blockquote><p>回家抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GoHome</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 买车票</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 坐车回家</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sitCar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goGome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        buyTicket();</span><br><span class="line">        sitCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坐火车回家类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoHomeByTrain</span> <span class="keyword">extends</span> <span class="title">GoHome</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去火车站买火车票"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sitCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去火车站坐车"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>坐大巴回家类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoHomeByBus</span> <span class="keyword">extends</span> <span class="title">GoHome</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去汽车站买汽车票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sitCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"去汽车站坐车"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面提出一个GoHome基类的实现方式就是利用抽象方法模式，抽象方法模式的核心思想就是将一件事的固定处理步骤的实现提取到基类中（如goHome方法），然后子类继承积累，并且子类只需要实现各个步骤的处理方法。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的函数接口</title>
      <link href="/2019/09/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/"/>
      <url>/2019/09/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E5%87%BD%E6%95%B0%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在看spring源码路径解析的时候，遇见了<code>helper.replacePlaceholders(text, this::getPropertyAsRawString);</code>。这里有个很奇怪的<code>this::getPropertyAsRawString</code>。<code>::</code>这个符号在C++中很眼熟，但是在java中还是第一次见（是我太菜没怎么学过java8，后面一定要补上。先在此记录。）,也不知道传了什么东西过去。</p><a id="more"></a><p>在好奇心的促使下，我点进了方法<code>replacePlaceholders</code>发现参数列表为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</span><br><span class="line">    <span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 发现第二个参数是<code>PlaceholderResolver</code>类型，而这个类型是一个<code>FunctionalInterface</code>接口，其源码如下：   </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Strategy interface used to resolve replacement values for placeholders contained in Strings.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaceholderResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Resolve the supplied placeholder name to the replacement value.</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> placeholderName the name of the placeholder to resolve</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span> the replacement value, or &#123;<span class="doctag">@code</span> null&#125; if no replacement is to be made</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="问题：FunctionalInterface注解作用"><a href="#问题：FunctionalInterface注解作用" class="headerlink" title="问题：FunctionalInterface注解作用"></a>问题：FunctionalInterface注解作用</h2><p>如这个注解的名字所示，这个接口只是向大家声明该接口是一个函数接口。而声明为函数接口，有如下要求：</p><ul><li>只能有一个抽象函数(但是有例外，详情见下)。</li><li>可以有default修饰的方法，因为default修饰的方法是已经实现了的</li><li>函数接口中抽象函数可以有多个，但是除了自定义的抽象函数之外的抽象函数必须是Object中已实现的方法。（如：下面的代码）   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaceholderResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hh "</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果不是Object中已经实现的方法，则会报错。如下图：</p><p><img src="https://user-images.githubusercontent.com/33340562/64415173-626eab00-d0c7-11e9-99a4-c8344c257eb9.png" alt="image"></p><p>知道函数接口的定义后，那函数接口怎么使用呢？以及他的作用</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><p>定义一个函数接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaceholderResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">resolvePlaceholder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个将函数接口作为参数的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(PlaceholderResolver placeholderResolver)</span> </span>&#123;</span><br><span class="line">    placeholderResolver.resolvePlaceholder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在定义一个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"我是print方法"</span>)</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在就可以愉快的使用了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">this</span>::print);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而上面调用test方法后就会输出在执行<code>placeholderResolver.resolvePlaceholder(“啦啦啦”);</code>时输出<code>我是print方法</code>。其作用也就是将print方法赋给PlaceholderResolver中的resolvePlaceholder，所以在调用resolvePlaceholder方法会执行print。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>究其到底函数接口只是一个语法糖，它是java8一个新的语法糖。它的效果等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    test(<span class="keyword">new</span> PlaceholderResolver() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在调用resolvePPlaceholder方法时会调用print方法。这样使用函数接口替代匿名内部类，可以是代码更加简洁。但要注意的是print方法要和resolvePlaceholder方法的参数列表、返回参数一致，方法名可以不一致。</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ant风格</title>
      <link href="/2019/09/01/Ant%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/09/01/Ant%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在阅读dalao的文章时，看到<code>支持Ant风格</code>。遂对<code>Ant风格</code>产生了好奇。遂写此blog以做笔记。</p><blockquote><p>Ant风格：就是匹配<code>路径</code>和<code>url</code>的一种规则。例如：我们常见的<code>C:/project/*.html</code>匹配C盘目录下project文件夹中的所有html文件。<br><a id="more"></a></p></blockquote><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><table><thead><tr><th>符号</th><th style="text-align:right">说明</th></tr></thead><tbody><tr><td>?</td><td style="text-align:right">匹配任何单字符</td></tr><tr><td>*</td><td style="text-align:right">匹配0或者任意数量的字符</td></tr><tr><td>**</td><td style="text-align:right">匹配0或者更多的目录</td></tr></tbody></table><p>例如<br>URL路径 | 说明<br>–|–:<br>/project/<em>.a|匹配项目根路径下所有在project路径下的.a文件<br>/project/p?ttern|匹配项目根路径下 /project/pattern 和 /app/pXttern,但是不包括/app/pttern<br>/<strong>/example|匹配项目根路径下 /project/example, /project/foow/example, 和 /example<br>/project/</strong>/dir/file.</em>|匹配项目根路径下/project/dir/file.jsp, /project/foow/dir/file.html,/project/foow/bar/dir/file.pdf<br>/*<em>/</em>.jsp|匹配项目根路径下任何的.jsp 文件</p><p>注意：如果一个路径存在多个匹配，那么将选择最长的匹配。<br>例如：URL请求/project/dir/file.jsp，现在存在两个路径匹配模式/*<em>/</em>.jsp和/project/dir/<em>.jsp，那么会根据模式/project/dir/</em>.jsp来匹配</p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>schemaLocation值必须具有偶数个URI</title>
      <link href="/2019/09/01/schemaLocation%E5%80%BC%E5%BF%85%E9%A1%BB%E5%85%B7%E6%9C%89%E5%81%B6%E6%95%B0%E4%B8%AAURI/"/>
      <url>/2019/09/01/schemaLocation%E5%80%BC%E5%BF%85%E9%A1%BB%E5%85%B7%E6%9C%89%E5%81%B6%E6%95%B0%E4%B8%AAURI/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习并使用spring框架开发已经有了一段很长的时间了，但是之前没有把在学习过程中遇见关于spring的错误积累下来。所以从现在开始，将在此开辟一博客收集我遇见的奇葩错误。</p><h2 id="错误一-SchemaLocation-schemaLocation-值必须具有偶数个-URI"><a href="#错误一-SchemaLocation-schemaLocation-值必须具有偶数个-URI" class="headerlink" title="错误一  SchemaLocation: schemaLocation 值必须具有偶数个 URI"></a>错误一  SchemaLocation: schemaLocation 值必须具有偶数个 URI</h2><blockquote><p>该错误是我在学习<code>ignoreDependencyInterface</code>和<code>ignoreDependencyType</code>之间的区别及使用的时候发现的。   </p></blockquote><a id="more"></a><p>我在配置spring的beans.xml时，设置<code><a href="context:annotation-config" target="_blank" rel="noopener">context:annotation-config</a>&lt;/context:annotation-config&gt;</code>。发现要在<code>beans</code>标签中加入<code>xmlns:context=”<a href="http://www.springframework.org/schema/context&quot;" target="_blank" rel="noopener">http://www.springframework.org/schema/context&quot;</a></code>。（因为我们要用到context标签所以要引入context）</p><p>加入后运行。   </p><blockquote><p>代码提示报错   </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line <span class="number">52</span> in XML document from file [C:\Users\Administrator\Downloads\adaptive-loadbalance-master-<span class="number">154377</span>df0a8f753f2ea462ec15a6f76f882691bc\study\src\main\resources\META-INF\spring\camel-context.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: <span class="number">52</span>; columnNumber: <span class="number">30</span>; cvc-complex-type.2.4.c: 通配符的匹配很全面, 但无法找到元素 <span class="string">'context:annotation-config'</span> 的声明。</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">404</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">336</span>)</span><br><span class="line">at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:<span class="number">304</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">188</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">224</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">195</span>)</span><br><span class="line">at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:<span class="number">257</span>)</span><br><span class="line">at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:<span class="number">128</span>)</span><br><span class="line">at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:<span class="number">94</span>)</span><br><span class="line">at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:<span class="number">133</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:<span class="number">636</span>)</span><br><span class="line">at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:<span class="number">521</span>)</span><br><span class="line">at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:<span class="number">142</span>)</span><br><span class="line">at org.springframework.context.support.FileSystemXmlApplicationContext.&lt;init&gt;(FileSystemXmlApplicationContext.java:<span class="number">85</span>)</span><br><span class="line">at study.Application.main(Application.java:<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>原因是因为在<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xsi:schemaLocation=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="line"><span class="string">       http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"</span></span><br></pre></td></tr></table></figure></p><p>中要加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/context</span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/context/spring-context.xsd</span></span><br></pre></td></tr></table></figure></p><p>刚开始年轻的我只加入了一个<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/context</span></span><br></pre></td></tr></table></figure></p><p>导致报错<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.xml.sax.SAXParseException: SchemaLocation: schemaLocation 值 <span class="string">'http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd        http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd       http://www.springframework.org/schema/context'</span> 必须具有偶数个 URI。</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次错误，我们可以知道要在beans.xml中加入一个标签的流程如下（以context为例）：</p><p>第一步：加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:context=<span class="string">"http://www.springframework.org/schema/context"</span></span><br></pre></td></tr></table></figure></p><p>第二步：在xsi:schemaLocation中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/context</span></span><br></pre></td></tr></table></figure></p><p>第三步：在xsi:schemaLocation中加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//www.springframework.org/schema/spring-context.xsd</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 错误 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer神秘的toStringCache属性</title>
      <link href="/2019/08/17/StringBuffer%E7%A5%9E%E7%A7%98%E7%9A%84toStringCache%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/08/17/StringBuffer%E7%A5%9E%E7%A7%98%E7%9A%84toStringCache%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr><p>大家都知道直接对String字符串进行拼接等操作时，会创建大量的String对象。因此用String直接进行这些操作效率会很低。所以催生了StringBuilder和StringBuffer这两个类。这两个类基本相同，但是StringBuffer多了一个toStringCache变量（后面具体讲解该变量作用），并在方法体上加了<code>synchronized</code>。<br><a id="more"></a></p><h2 id="StringBuilder和StringBuffer的相同点"><a href="#StringBuilder和StringBuffer的相同点" class="headerlink" title="StringBuilder和StringBuffer的相同点"></a>StringBuilder和StringBuffer的相同点</h2><hr><ul><li>都继承于AbstractStringBuilder类。</li><li>都实现了java.io.Serializable, CharSequence接口。</li><li>字符串都是存储在一个字符数组中。<h2 id="StringBuilder和StringBuffer不同点一"><a href="#StringBuilder和StringBuffer不同点一" class="headerlink" title="StringBuilder和StringBuffer不同点一"></a>StringBuilder和StringBuffer不同点一</h2></li></ul><hr><p>StringBuffer是线程安全的，而StringBuilder是线程不安全的。那StringBuffer是怎么实现线程安全的呢？通过源码的对比，可以看到两个类的实现大致相同，不一样的就是StringBuffer在方法体加了synchronized。</p><h2 id="StringBuilder和StringBuffer不同点二"><a href="#StringBuilder和StringBuffer不同点二" class="headerlink" title="StringBuilder和StringBuffer不同点二"></a>StringBuilder和StringBuffer不同点二</h2><hr><p>在对比两个类的源码，发现StringBuffer多了一个toStringCache<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A cache of the last value returned by toString. Cleared</span></span><br><span class="line"><span class="comment"> * whenever the StringBuffer is modified.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">char</span>[] toStringCache;</span><br></pre></td></tr></table></figure></p><p>这个属性的作用是缓存toString方法返回的最后一个值，当StringBuffer对象被修改时，这个变量都会被设置为NULL。</p><p><strong> toStringCache的作用 </strong></p><p>众所周知对字符串的操作效率StringBuilder &gt; StringBuffer &gt; String<br>也就是说StringBuffer的效率并不是最棒的，所以仍需提高，设置toStringCache的作用就是为了提高效率</p><p><strong> 问题来了：toStringCache是怎么提高效率的 </strong></p><h2 id="先看看StringBuilder和StringBuffer两个类中的toString方法"><a href="#先看看StringBuilder和StringBuffer两个类中的toString方法" class="headerlink" title="先看看StringBuilder和StringBuffer两个类中的toString方法"></a>先看看StringBuilder和StringBuffer两个类中的toString方法</h2><blockquote><p>StringBuffer的toString方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>StringBuilder的toString方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><p>从两个方法中可以看到StringBuffer已经将方法重写为了synchronized方法，已经实现了线程安全，可是方法的具体实现却不同。<br><strong> 两个方法创建String的方法分别为： </strong><br>new String(toStringCache, true);   –对应的构造方法–&gt;   String(char[] value, boolean share)<br>new String(value, 0, count); –&gt;对应的构造方法–&gt;  String(char value[], int offset, int count)  </p><p><strong> 所以现在需要去了解两个构造方法的不同 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处省略一部分代码</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count); <span class="comment">//复制数组到value</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//完整的函数，就是这么简单粗暴</span></span><br><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">   <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">   <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面可以看出<br>调用String(char[] value, boolean share) 不用复制数组<br>调用String(char value[], int offset, int count) 需要复制数组</p><p>再回到StringBuffer和StringBuilder的toString方法就知道StringBuffer只有当toStringCache是NULL的时候（也就是当字符串发生变化）需要复制数组，而StringBuilder的toString方法每次创建String都要复制数组。所以现在清楚了toStringCache就是这样提高一点点效率。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring中Bean的生命周期</title>
      <link href="/2019/07/22/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/07/22/Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我们都知道Spring的IOC容器帮我们管理着Bean，我们可以从IOC容器中拿到我们想要的Bean对象。但是IOC是如何管理我们的Bean呢？下面将会从源码分析的角度来介绍Spring中Bean的生命周期。</p></blockquote><h2 id="BeanFactory源码的部分注释-可粗略看下，后面将会进行讲解"><a href="#BeanFactory源码的部分注释-可粗略看下，后面将会进行讲解" class="headerlink" title="BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解)"></a>BeanFactory源码的部分注释(可粗略看下，后面将会进行讲解)</h2><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Bean factory implementations should support the standard bean lifecycle interfaces</span></span><br><span class="line"><span class="comment"> * as far as possible. The full set of initialization methods and their standard order is:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1. BeanNameAware's &#123;<span class="doctag">@code</span> setBeanName&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2. BeanClassLoaderAware's &#123;<span class="doctag">@code</span> setBeanClassLoader&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 3. BeanFactoryAware's &#123;<span class="doctag">@code</span> setBeanFactory&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 4. ResourceLoaderAware's &#123;<span class="doctag">@code</span> setResourceLoader&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 5. ApplicationEventPublisherAware's &#123;<span class="doctag">@code</span> setApplicationEventPublisher&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 6. MessageSourceAware's &#123;<span class="doctag">@code</span> setMessageSource&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 7. ApplicationContextAware's &#123;<span class="doctag">@code</span> setApplicationContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in an application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 8. ServletContextAware's &#123;<span class="doctag">@code</span> setServletContext&#125;</span></span><br><span class="line"><span class="comment"> * (only applicable when running in a web application context)&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 9. &#123;<span class="doctag">@code</span> postProcessBeforeInitialization&#125; methods of BeanPostProcessors&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 10. InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 11. a custom init-method definition&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 12. &#123;<span class="doctag">@code</span> postProcessAfterInitialization&#125; methods of BeanPostProcessors</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;On shutdown of a bean factory, the following lifecycle methods apply:&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1. DisposableBean's &#123;<span class="doctag">@code</span> destroy&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 2. a custom destroy-method definition</span></span><br><span class="line"><span class="comment"> **/</span></span><br></pre></td></tr></table></figure><h3 id="注释翻译（翻译错的请轻喷）"><a href="#注释翻译（翻译错的请轻喷）" class="headerlink" title="注释翻译（翻译错的请轻喷）"></a>注释翻译（翻译错的请轻喷）</h3><p>Bean工厂的实现者应该尽可能支持标准的Bean生命周期接口。<br>Bean的初始化方法和他们标准的执行顺序如下：<br>1.BeanNameAware的setBeanName方法<br>2.BeanClassLoaderAware的setBeanClassLoader方法<br>3.BeanFactoryAware的setBeanFactory方法<br>4.ResourceLoaderAware的setResourceLoader方法<br>5.ApplicationEventPublisherAware的setApplicationEventPublisher方法<br>6.MessageSourceAware的setMessageSource方法<br>7.ApplicationContextAware的setApplicationContext方法<br>8.ServletContextAware的setServletContext方法<br>9.BeanPostProcessors的postProcessAfterInitialization方法<br>初始化完毕 -&gt; 进行我们的业务操作<br>Bean的关闭生命周期调用方法<br>1.DisposableBean的destroy方法<br>2.在配置文件中指定的destroy-method方法</p><p>看完这个注释后，我们将回到源码找到Bean执行以上方法的地方。<br>通过调试我们可以找到执行上述步骤的方法为initializeBean方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码就为该方法，我将该方法分为四部分。</p><h3 id="第一部分执行所有的Aware方法"><a href="#第一部分执行所有的Aware方法" class="headerlink" title="第一部分执行所有的Aware方法"></a>第一部分执行所有的Aware方法</h3><p>也就是上面提到的invokeAwareMethods方法<br>该方法将XXXAware对应的XXX对象传给bean。<br>例如BeanNameAware就会将beanName传给bean。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第二部分执行Bean后置处理器的postProcessBeforeInitialization方法"><a href="#第二部分执行Bean后置处理器的postProcessBeforeInitialization方法" class="headerlink" title="第二部分执行Bean后置处理器的postProcessBeforeInitialization方法"></a>第二部分执行Bean后置处理器的postProcessBeforeInitialization方法</h3><p>Bean后置处理器也就是BeanPostProcessor的实现类。也就是initializeBean方法中applyBeanPostProcessorsBeforeInitialization调用。<br>在applyBeanPostProcessorsBeforeInitialization方法中，Spring将遍历执行系统自带的和用户定义的所有Bean后置处理器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span>  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第三部分执行Bean的Init方法"><a href="#第三部分执行Bean的Init方法" class="headerlink" title="第三部分执行Bean的Init方法"></a>第三部分执行Bean的Init方法</h3><p>在这里首先会判断Bean是否继承了InitializingBean接口<br>如果继承了InitializingBean接口，就调用InitializingBean接口的afterPropertiesSet方法。<br>然后判断用户在配置Bean的时候是否指定了init方法（xml配置为指定init-method，注解配置为PostConstruct）。<br>如果指定了就调用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                <span class="keyword">throw</span> pae.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (initMethodName != <span class="keyword">null</span> &amp;&amp; !(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步"><a href="#第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步" class="headerlink" title="第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步"></a>第四步执行Bean后置处理器的applyBeanPostProcessorsAfterInitialization方法同第二步</h3><hr><blockquote><p>到此Bean的初始化就完成了。后面就是Bean的销毁<br>销毁跟初始化调用Bean的init方法一样，不过在销毁的时候是判断Bean是否实现了DisposableBean接口，如果实现了就调用DisposableBean的destroy方法。然后在判断Bean是否指定了销毁方法（xml方式是destroy-method，注解方式是@PreDestroy）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (DestructionAwareBeanPostProcessor processor : <span class="keyword">this</span>.beanPostProcessors) &#123;</span><br><span class="line">            processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Invoking destroy() on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ((DisposableBean) bean).destroy();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, acc);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ((DisposableBean) bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            String msg = <span class="string">"Invocation of destroy method failed on bean with name '"</span> + <span class="keyword">this</span>.beanName + <span class="string">"'"</span>;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.warn(msg, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(msg + <span class="string">": "</span> + ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToCall = determineDestroyMethod();</span><br><span class="line">        <span class="keyword">if</span> (methodToCall != <span class="keyword">null</span>) &#123;</span><br><span class="line">            invokeCustomDestroyMethod(methodToCall);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Bean的生命周期总结"><a href="#Bean的生命周期总结" class="headerlink" title="Bean的生命周期总结"></a>Bean的生命周期总结</h2><blockquote><p>调用XXXAware方法的setXXX–&gt;调用Bean后置处理器的postProcessBeforeInitialization–&gt;调用InitializingBean接口的afterPropertiesSet方法–&gt;调用用户指定的初始方法–&gt;   业务  –&gt;调用DisposableBean接口的destory方法–&gt;调用用户指定的销毁方法</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BeanFactory、FactoryBean、ObjectFactory的区别</title>
      <link href="/2019/07/21/BeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/07/21/BeanFactory%E3%80%81FactoryBean%E3%80%81ObjectFactory%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这三个类都属于org.springframework.beans.factory包下，并且名字都有点相似，但在功能上却大部相同。具体有哪些不同呢？下面将从这三个类的功能与用法分别分析。</p></blockquote><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><blockquote><p>该类名以Factory结尾，其实质为一个Bean工厂接口，源码如下。从源码可以看出这个接口定义了Bean工厂的一些基本操作。所以这个接口起到了规范Bean工厂的基本操作作用。其基本实现有HierarchicalBeanFactory、ListableBeanFactory和ConfigurableBeanFactory以及各种ApplicationContext等等。如果想看BeanFactory的基本实现可以去看ListableBeanFactory的源码。而BeanFactory的使用则推荐使用ApplicationContext的一些派生类（如FileSystemXmlApplicationContext以及AnnotationConfigApplicationContext等类）</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>; <span class="comment">// 这个与FactoryBean有关，后面会介绍到</span></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>; <span class="comment">//是否是多例的意思</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">String[] getAliases(String name); <span class="comment">// 获取Bean的别名</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h2><blockquote><p>该类以Bean结尾，自然就是一个Bean，但这个Bean不是普通的Bean。这个Bean的设计类似于工厂模》&gt;式，专门用于创建特定的对象。可是Spring控制反转不是把对象的创建控制权交给了BeanFactory进行管理吗？那是因为有些创建比较复杂的类用配置文件来描述初始化不方便（Bean工厂要读取xml或者注解形式的类的初始化相关属性，这样Bean工厂才知道怎么帮我们创建该对象）。源码如下。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getObject方法便是这个FactoryBean创建对象的地方。调用这个方法就可以获取他创建的一个对象。</p><blockquote><p>使用方法（本次只展示xml方式）</p></blockquote><p>展示中涉及三个类<br><br>Test类：main方法<br><br>Car类：FactoryBean中构建的。<br><br>CarFactoryBean类：继承了FactoryBean专用来构建Car的。</p><blockquote><p>Car</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm Car"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CarFactoryBean在getObject方法中构建Car对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//FactoryBean专门用来创建初始化复杂的对象</span></span><br><span class="line">        <span class="comment">//此处假设在进行很复杂的构造对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Car();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Car.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm CarFactory"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>配置文件beans.xml。 注意此处name为bean对应的是CarFactoryBean,等下注意使用getBean方法获取的对象是什么。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"bean"</span> <span class="attr">class</span>=<span class="string">"com.test.CarFactoryBean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>Test</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        Object obj1 = ctx.getBean(<span class="string">"car"</span>);</span><br><span class="line">        System.out.println(obj1);</span><br><span class="line">        Object obj2 = ctx.getBean(<span class="string">"&amp;car"</span>);<span class="comment">// 注意这里的区别</span></span><br><span class="line">        System.out.println(obj2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>最后输出的结果如下</p></blockquote><p><img src="https://user-images.githubusercontent.com/33340562/61588886-352c7300-abd5-11e9-90f7-1ac0d1818130.png" alt="image"></p><p>所以大家发现了没，在配置文件中我们配置的是car对应CarFactoryBean对象的，但是在getBean(“car”)时，取到的却是Car对象。这正是FactoryBean作用之处，在getBean中自动的调用了FactoryBean的getObject方法，并将FactoryBean构建的对象返回。如果想得到的是CarFactoryBean对象呢？那就要在car前面加个&amp;符号(心细的同学可能记得前面BeanFactory源码中也提到了&amp;符号，其作用就是这个）。</p><blockquote><p>通过Debug看源码可以看出在AbstractBeanFactory类中的getObjectForBeanInstance方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Object beanInstance, String name, String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name) &amp;&amp; !(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否实现了FactoryBean接口，</span></span><br><span class="line">    <span class="comment">//如果没实现就返回bean对象。</span></span><br><span class="line">    <span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果实现了FactoryBean对象</span></span><br><span class="line">        <span class="comment">//则从FactoryBean中调用getObject方法获取对象</span></span><br><span class="line">        object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Return bean instance from factory.</span></span><br><span class="line">        FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">        <span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">        object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ObjectFactory"><a href="#ObjectFactory" class="headerlink" title="ObjectFactory"></a>ObjectFactory</h1><blockquote><p>跟FactoryBean一样，用工厂模式创建对象。源码如下。<br>那么竟然与FactoryBean类似，都是用于创建对象。那两者有什么区别呢？<br>我们注意到FactoryBean中还具有isSingleton、getObjectType等方法。<br>这些方法是专门用于bean工厂的。从这个接口的注释也可以得出FactoryBean是专为BeanFactory所设计（This interface is similar to {@link FactoryBean}, but implementations<br> of the latter are normally meant to be defined as SPI instances in a {@link BeanFactory}）。因此ObjectFactory只是一个普通的工厂模式中的工厂接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Defines a factory which can return an Object instance</span></span><br><span class="line"><span class="comment"> * (possibly shared or independent) when invoked.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is typically used to encapsulate a generic factory which</span></span><br><span class="line"><span class="comment"> * returns a new instance (prototype) of some target object on each invocation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is similar to &#123;<span class="doctag">@link</span> FactoryBean&#125;, but implementations</span></span><br><span class="line"><span class="comment"> * of the latter are normally meant to be defined as SPI instances in a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> BeanFactory&#125;, while implementations of this class are normally meant</span></span><br><span class="line"><span class="comment"> * to be fed as an API to other beans (through injection). As such, the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> getObject()&#125; method has different exception handling behavior.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Colin Sampaleanu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> FactoryBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return an instance (possibly shared or independent)</span></span><br><span class="line"><span class="comment"> * of the object managed by this factory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an instance of the bean (should never be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeansException in case of creation errors</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2019/06/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2019/06/06/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机常见英语单词翻译</title>
      <link href="/2019/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/04/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B8%B8%E8%A7%81%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 大杂烩 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 英语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云环境下配置Nginx的SSL证书</title>
      <link href="/2019/04/04/%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6/"/>
      <url>/2019/04/04/%E9%98%BF%E9%87%8C%E4%BA%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AENginx%E7%9A%84SSL%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云服务器Nginx环境下配置SSL证书"><a href="#阿里云服务器Nginx环境下配置SSL证书" class="headerlink" title="阿里云服务器Nginx环境下配置SSL证书"></a><center>阿里云服务器Nginx环境下配置SSL证书</center></h1><h2 id="HTTPS的认识"><a href="#HTTPS的认识" class="headerlink" title="HTTPS的认识"></a>HTTPS的认识</h2><p>### </p><blockquote><p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p></blockquote><p>&#8194;&#8194;一般我们的服务器默认使用http协议，而https协议则需要自己配置协议，所以当在浏览器输入栏输入域名前加https时，会显示无法访问（如图1-1所示)。所以本次我将记录下在阿里云服务器Nginx环境下配置https协议过程。如在其他云运行商，亦可参考。<br><a id="more"></a></p><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041349_337.png" alt="图1-1  没配置ssl证书时https访问无效"></p><h2 id="第一步：下载SSL证书"><a href="#第一步：下载SSL证书" class="headerlink" title="第一步：下载SSL证书"></a>第一步：下载SSL证书</h2><p><br></p><blockquote><p>SSL证书分为收费版和免费的，作为一个土豆丝，我只能申请免费版的ssl证书，为期一年，但是可以无限申请。至于在哪里下呢。请按如下步骤。</p></blockquote><h3 id="进入域名的云解析控制台"><a href="#进入域名的云解析控制台" class="headerlink" title="进入域名的云解析控制台"></a>进入域名的云解析控制台</h3><blockquote><p>（当然，前提是咱们有个域名）界面如图（2-1）所示<br> 在你要配置SSL证书的那一项点击旁边的更多，然后又一个SSL证书按钮（如图2-2），点击它。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041401_326.png" alt="图2-1  云解析控制台"><br><img src="http://ppf89if8g.bkt.clouddn.com/201904041404_248.png" alt="图2-2"></p><h3 id="申请Symantec-DV-SSL证书"><a href="#申请Symantec-DV-SSL证书" class="headerlink" title="申请Symantec DV SSL证书"></a>申请Symantec DV SSL证书</h3><blockquote><p>在阿里云平台中该证书是免费的，但是期限只有一年，一年后过期可再来申请。<br>如图2-3填写要申请的域名，刚开始我输入*想为所有二级域名配置ssl证书，但是发现申请的按钮是灰的。后来发现输入www则没事，输入别的应该也可以吧，大家可以试试。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041408_734.png" alt="图2-3"></p><h3 id="填写验证信息"><a href="#填写验证信息" class="headerlink" title="填写验证信息"></a>填写验证信息</h3><blockquote><p>大家在这里可能会遇见图2-4这种错误，但是大家不要方。<br>刚开始我也遇见了，后来发现他是在域名解析规则中添加了一个主机记录为_dnsauth的解析规则。<br>而域名解析规则更新到dns服务器上要等一会儿，所以大家乘这个机会喝杯茶，等下点击验证就ojbk。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041411_993.png" alt="图2-4"></p><h3 id="下载证书"><a href="#下载证书" class="headerlink" title="下载证书"></a>下载证书</h3><blockquote><p>上一步验证成功后，就会跳转到SSL证书下载页面（如图2-5）。大家根据自己的需求下载对应的证书就可以了，我是要配置Nginx的SSL证书所以这里我选择了Nginx版的。到此第一阶段就结束了。</p></blockquote><p><img src="http://ppf89if8g.bkt.clouddn.com/201904041413_941.png" alt="图2-5"></p><h2 id="第二步：配置Nginx"><a href="#第二步：配置Nginx" class="headerlink" title="第二步：配置Nginx"></a>第二步：配置Nginx</h2><h3 id="将证书上传服务器"><a href="#将证书上传服务器" class="headerlink" title="将证书上传服务器"></a>将证书上传服务器</h3><blockquote><p>我先将下载的压缩包解压开，然后里面会有一个pem和key文件。然后通过scp命令（命令如下）将该软件上传到服务器的Nginx配置文件夹中的一个文件夹(SSL文件夹，这个文件夹是我自己建的，大家可以上传到自己喜欢的目录中)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">scp -r 2020586_www.butong.live.key 2020586_www.butong.live.pem root@www.butong.live:/etc/nginx/ssl</span><br><span class="line">//格式</span><br><span class="line">scp -r 文件[ 文件] 用户名@域名或ip:/上传到的文件夹</span><br></pre></td></tr></table></figure><h3 id="修改nginx-conf文件"><a href="#修改nginx-conf文件" class="headerlink" title="修改nginx.conf文件"></a>修改nginx.conf文件</h3><blockquote><p>在server中添加以下几行代码（以下代码可与原来的配置http代码共存，所以无需删除之前http的配置）<br>然后保存退出运行 nginx -s reload命令重启Nginx即可。 </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    ssl on;</span><br><span class="line">    ssl_certificate ssl/2020586_www.butong.live.pem; # 你解压开的文件放在的目录</span><br><span class="line">    ssl_certificate_key ssl/2020586_www.butong.live.key; # 你解压开的文件放在的目录</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line">    、、、 # 后面的保持原来的配置文件不变即可</span><br></pre></td></tr></table></figure><blockquote><p>以上就是在阿里云环境下配置Nginx的ssl证书的完整过程。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTPS协议 </tag>
            
            <tag> SSL证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>error 与 exception的区别</title>
      <link href="/2019/02/24/error-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/02/24/error-%E4%B8%8E-exception%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Error与Exception的区别"><a href="#Error与Exception的区别" class="headerlink" title="Error与Exception的区别"></a><center>Error与Exception的区别</center></h1><hr><h2 id="同"><a href="#同" class="headerlink" title="同"></a>同</h2><blockquote><p>1:两者都继承自Throwable</p></blockquote><h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><blockquote><p>1: 可以是可被控制或不可控制(例如RuntimeException异常及其子类);<br>         注:可控不可控就看在代码编写时能否检测到异常;<br>2: 表示有一个程序员导致的错误;<br>3: 应该在应用级被处理;</p></blockquote><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><blockquote><p>1: 总是不可控的（即在编译期不可探测到异常;<br>2: 常用来表示系统错误;<br>3: 应该在系统级被捕获;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
